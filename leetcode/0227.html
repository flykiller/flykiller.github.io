<!DOCTYPE html>
<html lang="en"><head>

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Leetcode 0227. Basic Calculator II | Dmitry Babichev algorithms</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Leetcode 0227. Basic Calculator II" />
<meta name="author" content="Dmitry Babichev" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="This algorithm works for Basic Calculator (BC I) problem, where we can have only + - ( ) operations, for Basic Calculator II (BC II), where we can have only + - * / operations and also for Basic Calculator III (BC III), where we can have all + - * / ( ) operations." />
<meta property="og:description" content="This algorithm works for Basic Calculator (BC I) problem, where we can have only + - ( ) operations, for Basic Calculator II (BC II), where we can have only + - * / operations and also for Basic Calculator III (BC III), where we can have all + - * / ( ) operations." />
<meta property="og:site_name" content="Dmitry Babichev algorithms" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-04-02T10:03:58+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Leetcode 0227. Basic Calculator II" />
<script type="application/ld+json">
{"url":"/leetcode/0227.html","@type":"BlogPosting","headline":"Leetcode 0227. Basic Calculator II","dateModified":"2021-04-02T10:03:58+02:00","datePublished":"2021-04-02T10:03:58+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"/leetcode/0227.html"},"author":{"@type":"Person","name":"Dmitry Babichev"},"description":"This algorithm works for Basic Calculator (BC I) problem, where we can have only + - ( ) operations, for Basic Calculator II (BC II), where we can have only + - * / operations and also for Basic Calculator III (BC III), where we can have all + - * / ( ) operations.","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Dmitry Babichev algorithms" />
    






  
  
</head>

    
    <!-- for mathjax support -->
    
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Dmitry Babichev algorithms</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/content/">Content</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <span>[
  
]</span>

<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Leetcode 0227. Basic Calculator II</h1>
    <p class="post-meta"><time class="dt-published" datetime="2021-04-02T10:03:58+02:00" itemprop="datePublished">
        Apr 2, 2021
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>This algorithm works for <code class="language-plaintext highlighter-rouge">Basic Calculator (BC I)</code> problem, where we can have only <code class="language-plaintext highlighter-rouge">+ - ( )</code> operations, for <code class="language-plaintext highlighter-rouge">Basic Calculator II (BC II)</code>, where we can have only <code class="language-plaintext highlighter-rouge">+ - * /</code> operations and also for <code class="language-plaintext highlighter-rouge">Basic Calculator III (BC III)</code>, where we can have all <code class="language-plaintext highlighter-rouge">+ - * / ( )</code> operations.</p>

<h3 id="stack-of-monomials">Stack of monomials</h3>
<p>The idea is to use both stack and recursion (which can be seen as 2 stack, because recursion use implicit stack). First, let us consider, that we do not have any brackets. Then let us keep the stack of monomial, consider the example <code class="language-plaintext highlighter-rouge">s = 1*2 - 3\4*5 + 6</code>.  Then we want our stack to be equal to <code class="language-plaintext highlighter-rouge">[1*2, -3\4*5, 6]</code>, let us do it step by step:</p>
<ol>
  <li>Put 1 into stack, we have <code class="language-plaintext highlighter-rouge">stack = [1]</code>.</li>
  <li>We can see that operation is equal to <code class="language-plaintext highlighter-rouge">*</code>, so we pop the last element from our stack and put new element: <code class="language-plaintext highlighter-rouge">1*2</code>, now <code class="language-plaintext highlighter-rouge">stack = [1*2]</code>.</li>
  <li>Now, operation is equal to <code class="language-plaintext highlighter-rouge">-</code>, so we  put <code class="language-plaintext highlighter-rouge">-3</code> to stack and we have <code class="language-plaintext highlighter-rouge">stack = [1*2, -3]</code> now</li>
  <li>Now, operation is equal to <code class="language-plaintext highlighter-rouge">\</code>, so we pop the last element from stack and put <code class="language-plaintext highlighter-rouge">-3\4</code> instead, <code class="language-plaintext highlighter-rouge">stack = [1*2, -3\4]</code></li>
  <li>Now, operation is equal to <code class="language-plaintext highlighter-rouge">*</code>, so we pop last element from stack and put <code class="language-plaintext highlighter-rouge">-3\4*5</code> instead, <code class="language-plaintext highlighter-rouge">stack = [1*2, -3\4*5]</code>.</li>
  <li>Finally, operation is equal to <code class="language-plaintext highlighter-rouge">+</code>, so we put <code class="language-plaintext highlighter-rouge">6</code> to stack: <code class="language-plaintext highlighter-rouge">stack = [1*2, -3\4*5, 6]</code></li>
</ol>

<p>Now, all we need to do is to return sum of all elements in stack.</p>

<h3 id="how-to-deal-with-brackets">How to deal with brackets</h3>
<p>If we want to be able to process the brackets properly, all we need to do is to call our calculator recursively! When we see the open bracket <code class="language-plaintext highlighter-rouge">(</code>, we call calculator with the rest of our string, and when we see closed bracket ‘)’, we give back the value of expression inside brackets and the place where we need to start when we go out of recursion.</p>

<h3 id="complexity">Complexity</h3>
<p>Even though we have stack and also have recursion, we process every element only once, so time complexity is <code class="language-plaintext highlighter-rouge">O(n)</code>. Space complexity is also potentially <code class="language-plaintext highlighter-rouge">O(n)</code>, because we need to keep stacks, but each element not more than once.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Solution:
    def calculate(self, s):
        def update(op, v):
            if op == "+": stack.append(v)
            if op == "-": stack.append(-v)
            if op == "*": stack.append(stack.pop() * v)           #for BC II and BC III
            if op == "/": stack.append(int(stack.pop() / v))      #for BC II and BC III
    
        it, num, stack, sign = 0, 0, [], "+"
        
        while it &lt; len(s):
            if s[it].isdigit():
                num = num * 10 + int(s[it])
            elif s[it] in "+-*/":
                update(sign, num)
                num, sign = 0, s[it]
            elif s[it] == "(":                                        # For BC I and BC III
                num, j = self.calculate(s[it + 1:])
                it = it + j
            elif s[it] == ")":                                        # For BC I and BC III
                update(sign, num)
                return sum(stack), it + 1
            it += 1
        update(sign, num)
        return sum(stack)
</code></pre></div></div>

  </div><a class="u-url" href="/leetcode/0227.html" hidden></a>
</article>


      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
        <ul class="contact-list">
          <li class="p-name">Dmitry Babichev</li>
          <li><a class="u-email" href="mailto:dimitry008@gmail.com">dimitry008@gmail.com</a></li>
        </ul>
      </div>
      <div class="footer-col">
        <p>Here you can find solution to some algorithmic problems, at the moment it is mainly leetcode problems.
</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"></ul>
</div>

  </div>

</footer>
</body>

</html>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    processEscapes: true
  }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
The first part is used to enable inline equation.