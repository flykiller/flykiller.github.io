<!DOCTYPE html>
<html lang="en"><head>

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Leetcode 0141. Linked List Cycle | Dmitry Babichev algorithms</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Leetcode 0141. Linked List Cycle" />
<meta name="author" content="Dmitry Babichev" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="This is pretty classical and well-know problem about linked list. One way is just to put all linked list to for example hash table and check if we have repeating elements. However it will take O(n) space. There is better solution with only O(1) complexity. Imagine the following example: 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 3, the list with loop. Idea is to use two pointers, one is slow and one is fast, let us do several steps: At the beginning, both of them at number 1. Next step, slow pointer at 2 and fast at 3. Next step, slow pointer at 3 and fast at 5. Next step, slow pointer at 4 and fast at 3. Next step, slow pointer at 5 and fast is also 5, so we have the same element and we return True." />
<meta property="og:description" content="This is pretty classical and well-know problem about linked list. One way is just to put all linked list to for example hash table and check if we have repeating elements. However it will take O(n) space. There is better solution with only O(1) complexity. Imagine the following example: 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 3, the list with loop. Idea is to use two pointers, one is slow and one is fast, let us do several steps: At the beginning, both of them at number 1. Next step, slow pointer at 2 and fast at 3. Next step, slow pointer at 3 and fast at 5. Next step, slow pointer at 4 and fast at 3. Next step, slow pointer at 5 and fast is also 5, so we have the same element and we return True." />
<meta property="og:site_name" content="Dmitry Babichev algorithms" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-04-01T13:15:06+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Leetcode 0141. Linked List Cycle" />
<script type="application/ld+json">
{"url":"/leetcode/0141.html","@type":"BlogPosting","headline":"Leetcode 0141. Linked List Cycle","dateModified":"2021-04-01T13:15:06+02:00","datePublished":"2021-04-01T13:15:06+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"/leetcode/0141.html"},"author":{"@type":"Person","name":"Dmitry Babichev"},"description":"This is pretty classical and well-know problem about linked list. One way is just to put all linked list to for example hash table and check if we have repeating elements. However it will take O(n) space. There is better solution with only O(1) complexity. Imagine the following example: 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 3, the list with loop. Idea is to use two pointers, one is slow and one is fast, let us do several steps: At the beginning, both of them at number 1. Next step, slow pointer at 2 and fast at 3. Next step, slow pointer at 3 and fast at 5. Next step, slow pointer at 4 and fast at 3. Next step, slow pointer at 5 and fast is also 5, so we have the same element and we return True.","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Dmitry Babichev algorithms" />
    






  
  
</head>

    
    <!-- for mathjax support -->
    
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Dmitry Babichev algorithms</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/content/">Content</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <span>[
  
]</span>

<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Leetcode 0141. Linked List Cycle</h1>
    <p class="post-meta"><time class="dt-published" datetime="2021-04-01T13:15:06+02:00" itemprop="datePublished">
        Apr 1, 2021
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>This is pretty classical and well-know problem about linked list. One way is just to put all linked list to for example hash table and check if we have repeating elements. However it will take <code class="language-plaintext highlighter-rouge">O(n)</code> space. There is better solution with only <code class="language-plaintext highlighter-rouge">O(1)</code> complexity. Imagine the following example:
<code class="language-plaintext highlighter-rouge">1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 3</code>, the list with loop. Idea is to use two pointers, one is slow and one is fast, let us do several steps:</p>
<ol>
  <li>At the beginning, both of them at number <code class="language-plaintext highlighter-rouge">1</code>.</li>
  <li>Next step, slow pointer at <code class="language-plaintext highlighter-rouge">2</code> and fast at <code class="language-plaintext highlighter-rouge">3</code>.</li>
  <li>Next step, slow pointer at <code class="language-plaintext highlighter-rouge">3</code> and fast at <code class="language-plaintext highlighter-rouge">5</code>.</li>
  <li>Next step, slow pointer at <code class="language-plaintext highlighter-rouge">4</code> and fast at <code class="language-plaintext highlighter-rouge">3</code>.</li>
  <li>Next step, slow pointer at <code class="language-plaintext highlighter-rouge">5</code> and fast is also <code class="language-plaintext highlighter-rouge">5</code>, so we have the same element and we return <code class="language-plaintext highlighter-rouge">True</code>.</li>
</ol>

<p>If we do not have loop we will never have equal elements, if we have loop, because slow pointer moves with speed <code class="language-plaintext highlighter-rouge">1</code> and fast with speed <code class="language-plaintext highlighter-rouge">2</code>, fast pointer will always gain slow one.</p>

<p><strong>Complexity</strong>: time complexity is <code class="language-plaintext highlighter-rouge">O(n)</code>, space complexity is <code class="language-plaintext highlighter-rouge">O(1)</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">hasCycle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">):</span>
        <span class="n">slow</span> <span class="o">=</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">head</span>
        <span class="k">while</span> <span class="n">fast</span> <span class="ow">and</span> <span class="n">fast</span><span class="p">.</span><span class="nb">next</span><span class="p">:</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="nb">next</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="p">.</span><span class="nb">next</span>
            <span class="k">if</span> <span class="n">slow</span> <span class="o">==</span> <span class="n">fast</span><span class="p">:</span> <span class="k">return</span> <span class="bp">True</span>
            
        <span class="k">return</span> <span class="bp">False</span>
</code></pre></div></div>

<p><strong>Similar problems</strong>:
<strong>142: Linked List Cycle II:</strong>
<strong>287. Find the Duplicate Number:</strong></p>


  </div><a class="u-url" href="/leetcode/0141.html" hidden></a>
</article>


      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
        <ul class="contact-list">
          <li class="p-name">Dmitry Babichev</li>
          <li><a class="u-email" href="mailto:dimitry008@gmail.com">dimitry008@gmail.com</a></li>
        </ul>
      </div>
      <div class="footer-col">
        <p>Here you can find solution to some algorithmic problems, at the moment it is mainly leetcode problems.
</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"></ul>
</div>

  </div>

</footer>
</body>

</html>