<!DOCTYPE html>
<html lang="en"><head>

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Leetcode 0971. Flip Binary Tree To Match Preorder Traversal | Dmitry Babichev’s webpage</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Leetcode 0971. Flip Binary Tree To Match Preorder Traversal" />
<meta name="author" content="Dmitry Babichev" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="https://leetcode.com/problems/flip-binary-tree-to-match-preorder-traversal" />
<meta property="og:description" content="https://leetcode.com/problems/flip-binary-tree-to-match-preorder-traversal" />
<meta property="og:site_name" content="Dmitry Babichev’s webpage" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-07-28T22:19:26+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Leetcode 0971. Flip Binary Tree To Match Preorder Traversal" />
<script type="application/ld+json">
{"url":"/leetcode/0971.html","@type":"BlogPosting","headline":"Leetcode 0971. Flip Binary Tree To Match Preorder Traversal","dateModified":"2021-07-28T22:19:26+02:00","datePublished":"2021-07-28T22:19:26+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"/leetcode/0971.html"},"author":{"@type":"Person","name":"Dmitry Babichev"},"description":"https://leetcode.com/problems/flip-binary-tree-to-match-preorder-traversal","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Dmitry Babichev's webpage" />
    






  
  
</head>

    
    <!-- for mathjax support -->
    
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Dmitry Babichev&#39;s webpage</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/leetcode%20problems/">Leetcode problems</a><a class="page-link" href="/coding%20ideas/">Patterns</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <span>[
  
    
    <a href="/tag/tree"><code class="highligher-rouge"><nobr>tree</nobr></code>&nbsp;</a>
  
    
    <a href="/tag/dfs"><code class="highligher-rouge"><nobr>dfs</nobr></code>&nbsp;</a>
  
    
    <a href="/tag/bfs"><code class="highligher-rouge"><nobr>bfs</nobr></code>&nbsp;</a>
  
]</span>

<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Leetcode 0971. Flip Binary Tree To Match Preorder Traversal</h1>
    <p class="post-meta"><time class="dt-published" datetime="2021-07-28T22:19:26+02:00" itemprop="datePublished">
        Jul 28, 2021
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p><a href="https://leetcode.com/problems/flip-binary-tree-to-match-preorder-traversal"> <font color="blue">https://leetcode.com/problems/flip-binary-tree-to-match-preorder-traversal</font></a></p>

<h4 id="problem-statement">Problem statement:</h4>

<p>You are given the root of a binary tree with <code class="language-plaintext highlighter-rouge">n</code> nodes, where each node is uniquely assigned a value from <code class="language-plaintext highlighter-rouge">1</code> to <code class="language-plaintext highlighter-rouge">n</code>. You are also given a sequence of n values voyage, which is the desired pre-order traversal of the binary tree.</p>

<p>Any node in the binary tree can be flipped by swapping its left and right subtrees. For example, flipping node 1 will have the following effect:</p>

<p><img src="https://assets.leetcode.com/uploads/2021/02/15/fliptree.jpg" alt="closed_paren" title="Closed Parenthesis" width="250" /></p>

<p>Flip the smallest number of nodes so that the pre-order traversal of the tree matches voyage.</p>

<p>Return a list of the values of all flipped nodes. You may return the answer in any order. If it is impossible to flip the nodes in the tree to make the pre-order traversal match voyage, return the list [-1].</p>

<h4 id="solution">Solution:</h4>

<p>For me it was not medium problem, more like hard. First of all it is asked in problem statement to find the minimum number of flips, however in fact we do not have choice: I think everything is determenistic here. The first thing you need to think about when you see tree, it is dfs or bfs. Let us choose recursive dfs, it is usally easier to code and understand.</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">self.ans</code> is our list with flipped nodes.</li>
  <li><code class="language-plaintext highlighter-rouge">self.ind</code> is where exaclty at our <code class="language-plaintext highlighter-rouge">voyage</code> array we are now. This is tricky part! If you do not use something similar, you still can solve problem, but it will be more like <code class="language-plaintext highlighter-rouge">O(n^2)</code> complexity.</li>
</ol>

<p><code class="language-plaintext highlighter-rouge">dfs(node)</code> function will work recursively as usual.</p>
<ol>
  <li>Check if we go outside our tree or we out of elements in <code class="language-plaintext highlighter-rouge">voyage</code>, in this case we just go back.</li>
  <li>Also, we <strong>expect</strong>, that value of current node we are in now is equal to element we are currently in <code class="language-plaintext highlighter-rouge">voyage</code>: if it is not the case, no flipping can save this situation. So, if we see that this condition does not hold, we add <code class="language-plaintext highlighter-rouge">None</code> to the answer and return. In the end we going to check if we have <code class="language-plaintext highlighter-rouge">None</code> in answer or not.</li>
  <li>Define <code class="language-plaintext highlighter-rouge">dr = 1</code>: direction of traversal (means <code class="language-plaintext highlighter-rouge">left -&gt; right</code> and <code class="language-plaintext highlighter-rouge">-1</code> means <code class="language-plaintext highlighter-rouge">right -&gt; left</code>), also increase <code class="language-plaintext highlighter-rouge">self.ind</code> by one.</li>
  <li>Check if we need to do flip: we need if <code class="language-plaintext highlighter-rouge">node.left.val</code> is not equal to <code class="language-plaintext highlighter-rouge">voyage[self.ind]</code>: in this case what is expected to be next node in traversal is not equal to the next node in voyages. We add node to answer and change direction. Note, that in the opposite case we <strong>can not</strong> flip this node, that is everything is determenistic.</li>
  <li>Traverse children in right direction and run <code class="language-plaintext highlighter-rouge">dfs(child)</code>.</li>
  <li>In the end, run <code class="language-plaintext highlighter-rouge">dfs(root)</code> and check if we have <code class="language-plaintext highlighter-rouge">None</code> inside, if we have it means that at one moment of time we have impossible option and we need to return <code class="language-plaintext highlighter-rouge">[-1]</code>. In opposite case we return <code class="language-plaintext highlighter-rouge">self.ans</code>.</li>
</ol>

<h4 id="complexity">Complexity:</h4>
<p>What we did here is just traversed our tree, using dfs, so time complexity is <code class="language-plaintext highlighter-rouge">O(n)</code>, where <code class="language-plaintext highlighter-rouge">n</code> is number of nodes in tree. Space complexity is potentially <code class="language-plaintext highlighter-rouge">O(n)</code> as well.</p>

<h4 id="code">Code</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">flipMatchVoyage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">voyage</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">ans</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">ind</span> <span class="o">=</span> <span class="p">[],</span> <span class="mi">0</span>
        
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span> <span class="ow">or</span> <span class="bp">self</span><span class="p">.</span><span class="n">ind</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">voyage</span><span class="p">):</span> <span class="k">return</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span> <span class="o">!=</span> <span class="n">voyage</span><span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">ind</span><span class="p">]:</span> 
                <span class="bp">self</span><span class="p">.</span><span class="n">ans</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="n">dr</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">ind</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span>
            
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span> <span class="ow">and</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">val</span> <span class="o">!=</span> <span class="n">voyage</span><span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">ind</span><span class="p">]:</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">ans</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
                <span class="n">dr</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="p">[</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">][::</span><span class="n">dr</span><span class="p">]:</span>
                <span class="n">dfs</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                
        <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="bp">None</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">ans</span> <span class="k">else</span> <span class="bp">self</span><span class="p">.</span><span class="n">ans</span>
</code></pre></div></div>

<p>If you have any questions, feel free to ask. If you like solution and explanations, please <strong>Upvote!</strong></p>

<p>If you like the solution, you can <strong>upvote</strong> it on leetcode discussion section:<a href="https://leetcode.com/problems/flip-binary-tree-to-match-preorder-traversal/discuss/1132516/python-recursive-dfs-explained"> <font color="blue">Problem 0971</font></a></p>

  </div><a class="u-url" href="/leetcode/0971.html" hidden></a>
</article>


      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
        <ul class="contact-list">
          <li class="p-name">Dmitry Babichev</li>
          <li><a class="u-email" href="mailto:dimitry008@gmail.com">dimitry008@gmail.com</a></li>
        </ul>
      </div>
      <div class="footer-col">
        <p>Here you can find solution to some algorithmic problems, at the moment it is mainly leetcode problems.
</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"></ul>
</div>

  </div>

</footer>
</body>

</html>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    processEscapes: true
  }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>