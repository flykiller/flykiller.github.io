<!DOCTYPE html>
<html lang="en"><head>

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Leetcode 0107. Binary Tree Level Order Traversal II | Dmitry Babichev algorithms</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Leetcode 0107. Binary Tree Level Order Traversal II" />
<meta name="author" content="Dmitry Babichev" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Not the most optimal way, but for me the most intuitive is to use bfs traversal of our graph, put all information into some auxilary list, and then traverse this list and reconstruct output. Let us consider the following example in more details:" />
<meta property="og:description" content="Not the most optimal way, but for me the most intuitive is to use bfs traversal of our graph, put all information into some auxilary list, and then traverse this list and reconstruct output. Let us consider the following example in more details:" />
<meta property="og:site_name" content="Dmitry Babichev algorithms" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-04-01T13:12:10+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Leetcode 0107. Binary Tree Level Order Traversal II" />
<script type="application/ld+json">
{"url":"/leetcode/0107.html","@type":"BlogPosting","headline":"Leetcode 0107. Binary Tree Level Order Traversal II","dateModified":"2021-04-01T13:12:10+02:00","datePublished":"2021-04-01T13:12:10+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"/leetcode/0107.html"},"author":{"@type":"Person","name":"Dmitry Babichev"},"description":"Not the most optimal way, but for me the most intuitive is to use bfs traversal of our graph, put all information into some auxilary list, and then traverse this list and reconstruct output. Let us consider the following example in more details:","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Dmitry Babichev algorithms" />
    






  
  
</head>

    
    <!-- for mathjax support -->
    
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Dmitry Babichev algorithms</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/content/">Content</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <span>[
  
]</span>

<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Leetcode 0107. Binary Tree Level Order Traversal II</h1>
    <p class="post-meta"><time class="dt-published" datetime="2021-04-01T13:12:10+02:00" itemprop="datePublished">
        Apr 1, 2021
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>Not the most optimal way, but for me the most intuitive is to use <strong>bfs</strong> traversal of our graph, put all information into some auxilary list, and then traverse this list and reconstruct output.  Let us consider the following example in more details:</p>

<p><img src="https://assets.leetcode.com/users/images/df695acf-e9c8-4554-9790-6dcff54a71ba_1593674131.7202525.png" alt="image" /></p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">Out_temp</code> is temporary list with pairs: first element in pair is value of node and the second is level of this node. We use <strong>bfs</strong> with queue to traverse our tree and in the end we have
<code class="language-plaintext highlighter-rouge">Out_temp = [[3, 0], [9, 1], [20, 1], [15, 2], [7, 2]]</code>.</li>
  <li>The second step is to reconstruct level by level <code class="language-plaintext highlighter-rouge">Out</code> list: we traverse our <code class="language-plaintext highlighter-rouge">Out_temp</code> and if level of new element is not the same as previous, we create new sublist.</li>
</ol>

<p><strong>Complexity</strong> is <code class="language-plaintext highlighter-rouge">O(V)</code>, where <code class="language-plaintext highlighter-rouge">V</code> is number of nodes in our tree, because we use bfs traversal and then we have one more <code class="language-plaintext highlighter-rouge">O(V)</code> postprosessing of our data. Space complexity is also <code class="language-plaintext highlighter-rouge">O(V)</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">levelOrderBottom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span> <span class="k">return</span> <span class="p">[]</span>
    
        <span class="n">Out_temp</span><span class="p">,</span> <span class="n">deq</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">deque</span><span class="p">([[</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
    
        <span class="k">while</span> <span class="n">deq</span><span class="p">:</span>
            <span class="n">elem</span> <span class="o">=</span> <span class="n">deq</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="n">Out_temp</span><span class="p">.</span><span class="n">append</span><span class="p">([</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">val</span><span class="p">,</span> <span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
            <span class="k">if</span> <span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">left</span><span class="p">:</span>
                <span class="n">deq</span><span class="p">.</span><span class="n">append</span><span class="p">([</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">left</span><span class="p">,</span> <span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">right</span><span class="p">:</span>
                <span class="n">deq</span><span class="p">.</span><span class="n">append</span><span class="p">([</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">right</span><span class="p">,</span> <span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>

        <span class="n">Out</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Out_temp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">Out_temp</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">Out_temp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">Out_temp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">Out</span><span class="p">[</span><span class="n">Out_temp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]].</span><span class="n">append</span><span class="p">(</span><span class="n">Out_temp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Out</span><span class="p">.</span><span class="n">append</span><span class="p">([</span><span class="n">Out_temp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>

        <span class="k">return</span> <span class="n">Out</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

  </div><a class="u-url" href="/leetcode/0107.html" hidden></a>
</article>


      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
        <ul class="contact-list">
          <li class="p-name">Dmitry Babichev</li>
          <li><a class="u-email" href="mailto:dimitry008@gmail.com">dimitry008@gmail.com</a></li>
        </ul>
      </div>
      <div class="footer-col">
        <p>Here you can find solution to some algorithmic problems, at the moment it is mainly leetcode problems.
</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"></ul>
</div>

  </div>

</footer>
</body>

</html>