<!DOCTYPE html>
<html lang="en"><head>

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Leetcode 1923. Longest Common Subpath | Dmitry Babichev’s webpage</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Leetcode 1923. Longest Common Subpath" />
<meta name="author" content="Dmitry Babichev" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Problem statement" />
<meta property="og:description" content="Problem statement" />
<meta property="og:site_name" content="Dmitry Babichev’s webpage" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-01-15T23:14:47+03:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Leetcode 1923. Longest Common Subpath" />
<script type="application/ld+json">
{"url":"/leetcode/1923.html","@type":"BlogPosting","headline":"Leetcode 1923. Longest Common Subpath","dateModified":"2022-01-15T23:14:47+03:00","datePublished":"2022-01-15T23:14:47+03:00","mainEntityOfPage":{"@type":"WebPage","@id":"/leetcode/1923.html"},"author":{"@type":"Person","name":"Dmitry Babichev"},"description":"Problem statement","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Dmitry Babichev's webpage" />
    






  
  
</head>

    
    <!-- for mathjax support -->
    
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Dmitry Babichev&#39;s webpage</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/leetcode%20problems/">Leetcode problems</a><a class="page-link" href="/codeforces%20problems/">Codeforces problems</a><a class="page-link" href="/coding%20ideas/">Patterns</a><a class="page-link" href="/performance%20tricks/">Speed up</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <span>[
  
    
    <a href="/tag/array"><code class="highligher-rouge"><nobr>array</nobr></code>&nbsp;</a>
  
    
    <a href="/tag/binary search"><code class="highligher-rouge"><nobr>binary search</nobr></code>&nbsp;</a>
  
    
    <a href="/tag/rolling hash"><code class="highligher-rouge"><nobr>rolling hash</nobr></code>&nbsp;</a>
  
    
    <a href="/tag/suffix array"><code class="highligher-rouge"><nobr>suffix array</nobr></code>&nbsp;</a>
  
]</span>

<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Leetcode 1923. Longest Common Subpath</h1>
    <p class="post-meta"><time class="dt-published" datetime="2022-01-15T23:14:47+03:00" itemprop="datePublished">
        Jan 15, 2022
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h4 id="problem-statement">Problem statement</h4>

<p><a href="https://leetcode.com/problems/???/"> <font color="blue">https://leetcode.com/problems/???/</font></a></p>

<h4 id="solution-1">Solution 1</h4>
<p>For me when I see this problem I thought about problem <strong>1044. Longest Duplicate Substring</strong>, so I tried to implement this idea and I succeded in the end.</p>

<p>The idea is given length of substring of length <code class="language-plaintext highlighter-rouge">M</code> create rolling hashes and then check if we have the same hash for all elements in <code class="language-plaintext highlighter-rouge">paths</code>. We will use binary search to do search of <code class="language-plaintext highlighter-rouge">M</code>. The main difficulty here is that we have not letters from <code class="language-plaintext highlighter-rouge">a</code> to <code class="language-plaintext highlighter-rouge">z</code> but numbers from <code class="language-plaintext highlighter-rouge">1</code> to potentially <code class="language-plaintext highlighter-rouge">100000</code>, so probability of collision can be quite high. That is why I chose several different primes around <code class="language-plaintext highlighter-rouge">2^31</code> and check calculate hashes for each of them. In this way we can be sure, that if we get that we have the same hashes for each of this modules, it means that paths are equal. Also we can do early stoppings to break as soon as it happens that intersections of hashes sets is empty.</p>

<p><strong>Update</strong> Actually, evaluating hash with two given numbers is equavalent to evaluation hash to multiplication of this numbers. In python we can use as big number as possible, so if we choose big enough module we will pass. However how exaclty to choose this magical module is a good question: I choose number around 2^128 and it works fine for given tests. However we still can have collisions, and I think there is nothing we can do with it because of test case 71: we have <code class="language-plaintext highlighter-rouge">paths = [[1, 0]*k, [0,1]*k]</code> and when we evaluate hashes we have a lot of equal hashes for each of two persons. If we want to really compare strings we need to check <code class="language-plaintext highlighter-rouge">O(k)</code> options for each person, each of length <code class="language-plaintext highlighter-rouge">O(M)</code> and if <code class="language-plaintext highlighter-rouge">M &gt; k/2</code> (and it is, because anser is <code class="language-plaintext highlighter-rouge">2k-1</code>), then we have complexity like <code class="language-plaintext highlighter-rouge">O(k^2*log k)</code> for full algorithm, which is impossible to get without TLE. So what is the solution? Use different method, like <strong>suffix tries</strong>.</p>

<h4 id="complexity">Complexity</h4>
<p>We need <code class="language-plaintext highlighter-rouge">O(K)</code> time to calculate all hashes for given <code class="language-plaintext highlighter-rouge">M</code>, where <code class="language-plaintext highlighter-rouge">K = sum(paths[i].length)</code> is total length of paths. We do binary search, so we have <code class="language-plaintext highlighter-rouge">O(K*log T)</code> complexity, where <code class="language-plaintext highlighter-rouge">T</code> is the smallest length among paths.</p>

<h4 id="code">Code</h4>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">longestCommonSubpath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">paths</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">RabinKarp</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
            <span class="n">h</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="mi">17</span><span class="o">*</span><span class="n">M</span><span class="o">-</span><span class="mi">17</span><span class="p">))</span><span class="o">%</span><span class="n">q</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">17</span>
            <span class="n">all_hashes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span> 
                <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span> <span class="o">*</span> <span class="n">t</span> <span class="o">+</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">%</span> <span class="n">q</span>

            <span class="n">all_hashes</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">-</span> <span class="n">M</span><span class="p">):</span>
                <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span><span class="o">*</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">h</span><span class="p">)</span> <span class="o">+</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">M</span><span class="p">])</span><span class="o">%</span> <span class="n">q</span>
                <span class="n">all_hashes</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">all_hashes</span>
    
        <span class="n">m</span><span class="p">,</span> <span class="n">mod</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">paths</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">128</span><span class="p">)</span> <span class="o">-</span> <span class="mi">159</span>
        <span class="n">beg</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        
        <span class="k">while</span> <span class="n">beg</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">:</span>
            <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">beg</span> <span class="o">+</span> <span class="n">end</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
            <span class="n">tt</span> <span class="o">=</span> <span class="nb">set</span><span class="p">.</span><span class="n">intersection</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">RabinKarp</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">mod</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">])</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tt</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">beg</span> <span class="o">=</span> <span class="n">mid</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">mid</span>

        <span class="k">return</span> <span class="n">beg</span>
</code></pre></div></div>

<h4 id="solution-2-using-suffix-array">Solution 2, using suffix array</h4>
<p>I was not very familiar with prefix array previously, so I thought this will be the good opportunity to investigate this data structure.</p>

<p>The idea is to build so-called suffix array: let us consider for simplicity example <code class="language-plaintext highlighter-rouge">banana</code>. Then what we want to construct is list of all suffixes: <code class="language-plaintext highlighter-rouge">banana, anana, nana, ana, na, a</code> and then sort them in increasing order: we have <code class="language-plaintext highlighter-rouge">a, ana, anana, banana, na, nana</code>. Actually what we keep is order if indexes: <code class="language-plaintext highlighter-rouge">(5, 3, 1, 0, 4, 2)</code>. There are different ways how you can build it:</p>

<ol>
  <li>Very difficult, and quite heavy to implement with complexity <code class="language-plaintext highlighter-rouge">O(n)</code>. Moreover hidden constant is quite big and in python it will work quite slow.</li>
  <li>There is algorithm with complexity <code class="language-plaintext highlighter-rouge">O(n*log n)</code>. You can see the idea here https://cp-algorithms.com/string/suffix-array.html, It is easier to code (about 20-30 lines of code) and work OK.</li>
  <li>We can make previous approach in <code class="language-plaintext highlighter-rouge">O(n*log^2 n)</code> time, you can find details here http://web.stanford.edu/class/cs97si/suffix-array.pdf and actually in python it will work even faster than previous approach! And what I like the best that it can be written in very compact way in python, about 10-15 lines.</li>
  <li>There is bruteforce approach with complexity <code class="language-plaintext highlighter-rouge">O(n*n*log n)</code>, which can be coded in couple of lines, but is just too slow.</li>
</ol>

<p>So, as you probably guessed, I use approach <strong>3</strong> here. Let us consider example <code class="language-plaintext highlighter-rouge">[[0,1,2,3,4], [2,3,4], [4,0,1,2,3]]</code> and do some preprocessing first:</p>

<ol>
  <li>We create one big list <code class="language-plaintext highlighter-rouge">nums = [0, 1, 2, 3, 4, -1, 2, 3, 4, -2, 4, 0, 1, 2, 3, -3, -inf]</code>: where we add numbers <code class="language-plaintext highlighter-rouge">-1, ... -m</code> between our arrays and minus infinity in the end.</li>
  <li>Also we create array of group indexes <code class="language-plaintext highlighter-rouge">prs = [1, 1, 1, 1, 1, ?, 2, 2, 2, ?, 3, 3, 3, 3, 3, ?]</code>. Actually any symbol can be at question mark. Using this array we create dictionary <code class="language-plaintext highlighter-rouge">parts</code>, which given index will give us what part our index inside.</li>
  <li>Also we use <code class="language-plaintext highlighter-rouge">compare</code> function, which will compare strings of equal length <code class="language-plaintext highlighter-rouge">l</code>, starting with indexes <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">j</code>. Suffix array allows us to do it just in <code class="language-plaintext highlighter-rouge">O(1)</code> time, please follow cp-algorithms link I provided earlier.</li>
  <li>Create suffix array <code class="language-plaintext highlighter-rouge">c</code> from nums: actually what it have is <code class="language-plaintext highlighter-rouge">log K</code> layers, and create also <code class="language-plaintext highlighter-rouge">sa</code>: inversion of transposition of the last layer.</li>
  <li>Now we do binary search with parameter <code class="language-plaintext highlighter-rouge">mid</code>. For this parameter we look at all substrings with length <code class="language-plaintext highlighter-rouge">mid</code>: there will be <code class="language-plaintext highlighter-rouge">O(K)</code> of them. Moreover, we have order of sorted prefixes, if we try to sort these substrings, we will have almost the same order, but now instead of strictly increasing we can have equalities: consider our <code class="language-plaintext highlighter-rouge">banana</code> case, if we choose <code class="language-plaintext highlighter-rouge">mid = 2</code>, we will have <code class="language-plaintext highlighter-rouge">an, an, ba, na, na</code>, so we compare all adjacent pairs and separate it into groups <code class="language-plaintext highlighter-rouge">(an, an), (ba), (na, na)</code>.</li>
  <li>Check every group: if it has less than <code class="language-plaintext highlighter-rouge">m</code> elements, we can skip this group, because we need at least <code class="language-plaintext highlighter-rouge">m</code> repetitions. If we have at least <code class="language-plaintext highlighter-rouge">m</code> elemens, we need to check that indexes cover all parts, that is all persons. Exactly for this we created <code class="language-plaintext highlighter-rouge">parts</code> dictionary: we look at every index and see what group it is inside. If we covered all groups, we are happy and we mark <code class="language-plaintext highlighter-rouge">Found</code> equal to <code class="language-plaintext highlighter-rouge">True</code> and break. Then we do binary search step: choose one of two halves.</li>
</ol>

<h4 id="complexity-1">Complexity</h4>
<p>Time complexity to build suffix array is <code class="language-plaintext highlighter-rouge">O(K * log^2K)</code>. Then we do binary search, each time spending <code class="language-plaintext highlighter-rouge">O(K)</code> time, so total time complexity is <code class="language-plaintext highlighter-rouge">O(K * log ^2 K + K * log T)</code>. It barely passes tests. Space complexity is <code class="language-plaintext highlighter-rouge">O(K)</code>.  (see notations in previous approach)</p>

<h4 id="code-1">Code</h4>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">longestCommonSubpath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">paths</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
            <span class="n">ls</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">l</span><span class="p">)))</span>
            <span class="n">index</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ls</span><span class="p">)}</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">l</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">suffixArray</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">merge</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">ans</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="n">line</span><span class="p">]</span>
            <span class="k">while</span> <span class="nb">max</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">merge</span><span class="p">([</span><span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">in</span>
                     <span class="n">zip_longest</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">islice</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span> <span class="n">fillvalue</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)])</span>
                <span class="n">ans</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">ans</span> <span class="o">+</span> <span class="p">[</span><span class="n">line</span><span class="p">],</span> <span class="n">k</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">ans</span>
        
        <span class="k">def</span> <span class="nf">compare</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
            <span class="n">k1</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">k1</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="n">k1</span><span class="p">][(</span><span class="n">i</span><span class="o">+</span><span class="n">l</span><span class="o">-</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">k</span><span class="p">))</span><span class="o">%</span><span class="n">n</span><span class="p">])</span>
            <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">k1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="n">k1</span><span class="p">][(</span><span class="n">j</span><span class="o">+</span><span class="n">l</span><span class="o">-</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">k</span><span class="p">))</span><span class="o">%</span><span class="n">n</span><span class="p">])</span>
            <span class="k">return</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span> <span class="k">else</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
        
        <span class="n">nums</span><span class="p">,</span> <span class="n">prs</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">paths</span><span class="p">):</span>
            <span class="n">nums</span><span class="p">.</span><span class="n">extend</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
            <span class="n">nums</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">i</span><span class="p">)</span>
            <span class="n">prs</span><span class="p">.</span><span class="n">extend</span><span class="p">([</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
            <span class="n">prs</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">i</span><span class="p">)</span>
        <span class="n">nums</span> <span class="o">+=</span> <span class="p">[</span><span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="s">"inf"</span><span class="p">)]</span>
        
        <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">paths</span><span class="p">)</span>
        
        <span class="n">c</span> <span class="o">=</span> <span class="n">suffixArray</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="n">sa</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">sa</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
            
        <span class="n">parts</span> <span class="o">=</span> <span class="p">{</span><span class="n">j</span><span class="p">:</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">prs</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">))}</span>
                
        <span class="n">beg</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        
        <span class="k">while</span> <span class="n">beg</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">:</span>
            <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">beg</span> <span class="o">+</span> <span class="n">end</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
            <span class="n">mid_log</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">log2</span><span class="p">(</span><span class="n">mid</span><span class="p">)),</span> <span class="mi">0</span>

            <span class="n">groups</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                <span class="n">q</span> <span class="o">=</span> <span class="n">compare</span><span class="p">(</span><span class="n">sa</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">sa</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">mid</span><span class="p">,</span> <span class="n">mid_log</span><span class="p">)</span>
                <span class="n">a</span> <span class="o">+=</span> <span class="n">q</span>
                <span class="n">groups</span><span class="p">[</span><span class="n">a</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">sa</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="n">Found</span> <span class="o">=</span> <span class="bp">False</span>

            <span class="k">for</span> <span class="n">gr</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gr</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">:</span> <span class="k">continue</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">gr</span><span class="p">))</span> <span class="o">==</span> <span class="n">m</span><span class="p">:</span>
                    <span class="n">Found</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">break</span>
                    
            <span class="k">if</span> <span class="n">Found</span> <span class="p">:</span>
                <span class="n">beg</span> <span class="o">=</span> <span class="n">mid</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">mid</span>

        <span class="k">return</span> <span class="n">beg</span>
</code></pre></div></div>

  </div><a class="u-url" href="/leetcode/1923.html" hidden></a>
</article>


      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
        <ul class="contact-list">
          <li class="p-name">Dmitry Babichev</li>
          <li><a class="u-email" href="mailto:dimitry008@gmail.com">dimitry008@gmail.com</a></li>
        </ul>
      </div>
      <div class="footer-col">
        <p>Here you can find solution to some algorithmic problems, at the moment it is mainly leetcode problems.
</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"></ul>
</div>

  </div>

</footer>
</body>

</html>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    processEscapes: true
  }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>