<!DOCTYPE html>
<html lang="en"><head>

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Leetcode 1397. Find All Good Strings | Dmitry Babichev’s webpage</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Leetcode 1397. Find All Good Strings" />
<meta name="author" content="Dmitry Babichev" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="https://leetcode.com/problems/find-all-good-strings" />
<meta property="og:description" content="https://leetcode.com/problems/find-all-good-strings" />
<meta property="og:site_name" content="Dmitry Babichev’s webpage" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-02-24T19:51:12+03:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Leetcode 1397. Find All Good Strings" />
<script type="application/ld+json">
{"url":"/leetcode/1397.html","@type":"BlogPosting","headline":"Leetcode 1397. Find All Good Strings","dateModified":"2022-02-24T19:51:12+03:00","datePublished":"2022-02-24T19:51:12+03:00","mainEntityOfPage":{"@type":"WebPage","@id":"/leetcode/1397.html"},"author":{"@type":"Person","name":"Dmitry Babichev"},"description":"https://leetcode.com/problems/find-all-good-strings","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Dmitry Babichev's webpage" />
    






  



</head>

    
    <!-- for mathjax support -->
    
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Dmitry Babichev&#39;s webpage</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/codeforces%20problems/">Codeforces</a><a class="page-link" href="/leetcode%20problems/">Leetcode problems</a><a class="page-link" href="/binarysearch%20problems/">BinarySearch</a><a class="page-link" href="/coding%20ideas/">Patterns</a><a class="page-link" href="/performance%20tricks/">Speed up</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <span>[
  
    
    <a href="/tag/dp"><code class="highligher-rouge"><nobr>dp</nobr></code>&nbsp;</a>
  
    
    <a href="/tag/string"><code class="highligher-rouge"><nobr>string</nobr></code>&nbsp;</a>
  
    
    <a href="/tag/kmp"><code class="highligher-rouge"><nobr>kmp</nobr></code>&nbsp;</a>
  
]</span>

<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Leetcode 1397. Find All Good Strings</h1>
    <p class="post-meta"><time class="dt-published" datetime="2022-02-24T19:51:12+03:00" itemprop="datePublished">
        Feb 24, 2022
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p><a href="https://leetcode.com/problems/find-all-good-strings"> <font color="blue">https://leetcode.com/problems/find-all-good-strings</font></a></p>

<h4 id="solution-1-optimal-complexity-but-difficult-to-code-and-understand">Solution 1: optimal complexity, but difficult to code and understand</h4>

<h5 id="part-1-prefix-function">Part 1: Prefix function</h5>
<p>Remind the definition of prefix function on a simple example: let <code class="language-plaintext highlighter-rouge">s = ababcaba</code>, then prefix funtion is <code class="language-plaintext highlighter-rouge">[0,0,1,2,0,1,2,3]</code>, because for example for substring <code class="language-plaintext highlighter-rouge">ababcab</code>, the longest equal prefix and suffix <code class="language-plaintext highlighter-rouge">ab</code> have length 2. There is efficient way to evaluate prefix function, using KMP algorighm. More precisely our function <code class="language-plaintext highlighter-rouge">prefix(self, s)</code> will give us the length of longest common prefix and suffix, for example for our <code class="language-plaintext highlighter-rouge">s = ababcaba</code> result will be equal to 3 and we can find it in O(len(s)).</p>

<h5 id="part-2-preprosess-evil">Part 2: Preprosess evil</h5>
<p>Now, we want to preprocess our <code class="language-plaintext highlighter-rouge">evil</code> string and create some useful data, we are going ot use later. Let us againg consider <code class="language-plaintext highlighter-rouge">A = evil = ababcaba</code>. Create <code class="language-plaintext highlighter-rouge">connections</code> as <code class="language-plaintext highlighter-rouge">T by k</code> matrix, where <code class="language-plaintext highlighter-rouge">T</code> is the size of our alphabet and <code class="language-plaintext highlighter-rouge">k = len(evil)</code>. In <code class="language-plaintext highlighter-rouge">connections[i][j]</code> we are going to store the length of maximum suffix of string <code class="language-plaintext highlighter-rouge">A_0,...,A_{i-1} + char(j)</code> which is at the same time is prefix of <code class="language-plaintext highlighter-rouge">A</code> (here char(0) = “a”, char(1) = “b” and so on). A bit difficult to understand, let us consider example: <code class="language-plaintext highlighter-rouge">connections[3][0] = 1</code>, because <code class="language-plaintext highlighter-rouge">A_0 A_1 A_2 + char(0) = abaa</code> and this string has suffix <code class="language-plaintext highlighter-rouge">a</code> which is prefix of <code class="language-plaintext highlighter-rouge">A</code>. <code class="language-plaintext highlighter-rouge">connections[3][1] = 4</code>, because  <code class="language-plaintext highlighter-rouge">A_0 A_1 A_2 + char(1) = abab</code>, which is prefix of <code class="language-plaintext highlighter-rouge">A</code>.
Let us fully fill this table <code class="language-plaintext highlighter-rouge">connections</code>:</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
      <th>e</th>
      <th>f</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>k = 0, starts with “”</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <td>k = 1, starts with “a”</td>
      <td>1</td>
      <td>2</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <td>k = 2, starts with “ab”</td>
      <td>3</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <td>k = 3, starts with “aba”</td>
      <td>1</td>
      <td>4</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <td>k = 4, starts with “abab”</td>
      <td>3</td>
      <td>0</td>
      <td>5</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <td>k = 5, starts with “ababc”</td>
      <td>6</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <td>k = 6, starts with “ababca”</td>
      <td>1</td>
      <td>7</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <td>k = 7, starts with “ababcab”</td>
      <td>8</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

<p>Let us note one thing: there is <strong>a lot</strong> of zeros in this table, we can say that this table is sparse. So, we can write this table in different way, I called this list <code class="language-plaintext highlighter-rouge">conn</code>:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">conn[0] = [0,1]</code></li>
  <li><code class="language-plaintext highlighter-rouge">conn[1] = [0,1], [1,2]</code></li>
  <li><code class="language-plaintext highlighter-rouge">conn[2] = [0,3]</code></li>
  <li><code class="language-plaintext highlighter-rouge">conn[3] = [0,1], [1,4]</code></li>
  <li><code class="language-plaintext highlighter-rouge">conn[4] = [0,3], [2,5]</code></li>
  <li><code class="language-plaintext highlighter-rouge">conn[5] = [0,6]</code></li>
  <li><code class="language-plaintext highlighter-rouge">conn[6] = [0,1], [1,7]</code></li>
  <li><code class="language-plaintext highlighter-rouge">conn[7] = [0,8]</code></li>
</ol>

<p>Looks better, is it? Howerer we still need one more table: <code class="language-plaintext highlighter-rouge">connections_num_zeros</code>, where we keep for every <code class="language-plaintext highlighter-rouge">k</code> and <code class="language-plaintext highlighter-rouge">j</code> number of zero elements in <code class="language-plaintext highlighter-rouge">k</code>-th row of matrix <code class="language-plaintext highlighter-rouge">connections</code>, which we met before element number <code class="language-plaintext highlighter-rouge">j</code>. Why we need this in the future? Because we need to deal with alphabetical order.</p>

<h5 id="part-3-dynamic-progaramming">Part 3: Dynamic progaramming</h5>
<p>Let us reformulate a bit our original problem and introduce funcion <code class="language-plaintext highlighter-rouge">findLesserGood(self, n, k, string, N, evil)</code>, where <code class="language-plaintext highlighter-rouge">n</code> is length of or <code class="language-plaintext highlighter-rouge">string</code>, <code class="language-plaintext highlighter-rouge">k</code> is length of <code class="language-plaintext highlighter-rouge">evil</code> and <code class="language-plaintext highlighter-rouge">N</code> is modulo which we use for long arithmetics. This function finds number of strings alphabetically less or equal than <code class="language-plaintext highlighter-rouge">string</code>, such that it do not have <code class="language-plaintext highlighter-rouge">evil</code> substring inside. Then it is enough to apply this function twice (for <code class="language-plaintext highlighter-rouge">s1</code>, <code class="language-plaintext highlighter-rouge">s2</code>), get difference and handle border case (string <code class="language-plaintext highlighter-rouge">s1</code>).</p>

<p>We have <code class="language-plaintext highlighter-rouge">dp_bord[i][j]</code> and <code class="language-plaintext highlighter-rouge">dp_notb[i][j]</code> two  <code class="language-plaintext highlighter-rouge">n x k</code> arrays, first one to handle border cases, where we search for number of strings, starting with <code class="language-plaintext highlighter-rouge">i</code> characters of <code class="language-plaintext highlighter-rouge">string</code> and such that its longest suffix equal to prefix of <code class="language-plaintext highlighter-rouge">evil</code> has length <code class="language-plaintext highlighter-rouge">j</code>. Border cases means that next element we can take should be more or equal than corresponding element is <code class="language-plaintext highlighter-rouge">string</code>.  Second array <code class="language-plaintext highlighter-rouge">dp_notb[i][j]</code> is for not border cases with the same logic it is number of all string of length <code class="language-plaintext highlighter-rouge">i</code>, such that the longest common suffix of it and prefix of <code class="language-plaintext highlighter-rouge">evil</code> has lengh <code class="language-plaintext highlighter-rouge">j</code>.</p>

<p>Precalcualted matrices help us efficiently update our tables: when we try to add new symbol we need to understand in <code class="language-plaintext highlighter-rouge">O(1)</code>, how changes its longes common suffix and prefix of string <code class="language-plaintext highlighter-rouge">evil</code>. That is why we evaluated our <code class="language-plaintext highlighter-rouge">connections</code> and <code class="language-plaintext highlighter-rouge">con</code> tables.</p>

<h5 id="part-4-complexity">Part 4: Complexity</h5>
<p><code class="language-plaintext highlighter-rouge">n</code> is lenth of original string <code class="language-plaintext highlighter-rouge">s1</code> and <code class="language-plaintext highlighter-rouge">s2</code>, <code class="language-plaintext highlighter-rouge">k</code> is length of <code class="language-plaintext highlighter-rouge">evil</code> and <code class="language-plaintext highlighter-rouge">T</code> is the size of alphabet.</p>

<p>To create connections in part 2 we have complexity <code class="language-plaintext highlighter-rouge">O(k^2T)</code> (I think it can be improved to <code class="language-plaintext highlighter-rouge">O(kT)</code> if we do it in smarter way, but it is not the bottleneck, so we keep it like this), because we iterate over k, over all alphabet and apply our <code class="language-plaintext highlighter-rouge">O(k)</code> complexity prefix function once inside, same time is needed to evaluate <code class="language-plaintext highlighter-rouge">connections_num_zeros</code>. Memory here is <code class="language-plaintext highlighter-rouge">O(Tk)</code> to keep couple of matrixes.</p>

<p>Complexity of <code class="language-plaintext highlighter-rouge">findLesserGood</code> is <code class="language-plaintext highlighter-rouge">O(nkT)</code>: there is two loops with size <code class="language-plaintext highlighter-rouge">n</code> and <code class="language-plaintext highlighter-rouge">k</code> and also inside we go over all <code class="language-plaintext highlighter-rouge">conn</code> list, which is sure not more than <code class="language-plaintext highlighter-rouge">k</code>. In fact, this complexity is equal to <code class="language-plaintext highlighter-rouge">O(nk)</code>, because matrix <code class="language-plaintext highlighter-rouge">connections</code> is very sparse and <code class="language-plaintext highlighter-rouge">conn</code> has <code class="language-plaintext highlighter-rouge">O(k)</code> elements instead of <code class="language-plaintext highlighter-rouge">O(kT)</code> (if I am wrong, please let me know!). Space complexity is obviously <code class="language-plaintext highlighter-rouge">O(nk)</code>.</p>

<p>Finally, time complexity is <code class="language-plaintext highlighter-rouge">O(nk + k^2T) = O(nk)</code> for our constraints and space complexity is <code class="language-plaintext highlighter-rouge">O(Tk + nk) = O(nk)</code> also.</p>

<h5 id="part-5-code">Part 5. Code</h5>
<p>Now, if we put all the stuff we discussed togeter, we can have the following code:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">prefix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">while</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">s</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">!=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> 
                <span class="n">k</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>
        <span class="k">return</span> <span class="n">p</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">CreateConnections</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evil</span><span class="p">,</span> <span class="n">T</span><span class="p">):</span>
        <span class="n">k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">evil</span><span class="p">)</span>
        <span class="n">connections</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">T</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span>
        <span class="n">conn</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">letter</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">alphabet</span><span class="p">:</span>
                <span class="n">curr_max</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">prefix</span><span class="p">(</span><span class="n">evil</span> <span class="o">+</span> <span class="s">"#"</span> <span class="o">+</span> <span class="n">evil</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">letter</span><span class="p">)</span>
               
                <span class="k">if</span> <span class="n">curr_max</span> <span class="o">!=</span> <span class="n">k</span><span class="p">:</span>    <span class="c1">#process case when we reached the end of evil string
</span>                    <span class="n">connections</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="nb">ord</span><span class="p">(</span><span class="n">letter</span><span class="p">)</span> <span class="o">-</span> <span class="nb">ord</span><span class="p">(</span><span class="s">"a"</span><span class="p">)]</span> <span class="o">=</span> <span class="n">curr_max</span>

                    <span class="k">if</span> <span class="n">curr_max</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">conn</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">append</span><span class="p">([</span><span class="nb">ord</span><span class="p">(</span><span class="n">letter</span><span class="p">)</span> <span class="o">-</span> <span class="nb">ord</span><span class="p">(</span><span class="s">"a"</span><span class="p">),</span> <span class="n">curr_max</span><span class="p">])</span>

        <span class="n">connections_num_zeros</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">T</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">connections_num_zeros</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">connections_num_zeros</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">connections</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)]</span>

        <span class="k">return</span> <span class="n">connections_num_zeros</span><span class="p">,</span> <span class="n">conn</span>

    <span class="k">def</span> <span class="nf">findLesserGood</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">evil</span><span class="p">):</span>
        <span class="n">dp_bord</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">k</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
        <span class="n">dp_notb</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">k</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
          
        <span class="n">dp_bord</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                  
        <span class="k">for</span> <span class="n">it_n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">it_k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="n">ord_num</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">string</span><span class="p">[</span><span class="n">it_n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="nb">ord</span><span class="p">(</span><span class="s">"a"</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">letter</span><span class="p">,</span> <span class="n">s</span>  <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">con</span><span class="p">[</span><span class="n">it_k</span><span class="p">]:</span>
                    <span class="n">dp_notb</span><span class="p">[</span><span class="n">it_n</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">s</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dp_notb</span><span class="p">[</span><span class="n">it_n</span><span class="p">][</span><span class="n">it_k</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">letter</span> <span class="o">&lt;</span> <span class="n">ord_num</span><span class="p">:</span>
                        <span class="n">dp_notb</span><span class="p">[</span><span class="n">it_n</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">s</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dp_bord</span><span class="p">[</span><span class="n">it_n</span><span class="p">][</span><span class="n">it_k</span><span class="p">]</span>

                <span class="n">dp_notb</span><span class="p">[</span><span class="n">it_n</span> <span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="p">.</span><span class="n">con_numzero</span><span class="p">[</span><span class="n">it_k</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">dp_notb</span><span class="p">[</span><span class="n">it_n</span><span class="p">][</span><span class="n">it_k</span><span class="p">]</span>     
                <span class="n">dp_notb</span><span class="p">[</span><span class="n">it_n</span> <span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="p">.</span><span class="n">con_numzero</span><span class="p">[</span><span class="n">it_k</span><span class="p">][</span><span class="n">ord_num</span><span class="p">]</span> <span class="o">*</span> <span class="n">dp_bord</span><span class="p">[</span><span class="n">it_n</span><span class="p">][</span><span class="n">it_k</span><span class="p">]</span>
                        
                <span class="n">dp_notb</span><span class="p">[</span><span class="n">it_n</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">it_k</span><span class="p">]</span> <span class="o">%=</span> <span class="n">N</span>

            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">prefix</span><span class="p">(</span><span class="n">evil</span> <span class="o">+</span> <span class="s">"#"</span> <span class="o">+</span> <span class="n">string</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">it_n</span><span class="o">+</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">!=</span> <span class="n">k</span> <span class="ow">and</span> <span class="nb">sum</span><span class="p">(</span><span class="n">dp_bord</span><span class="p">[</span><span class="n">it_n</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">dp_bord</span><span class="p">[</span><span class="n">it_n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
   
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">dp_bord</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">dp_notb</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">findGoodStrings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">evil</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">alphabet</span> <span class="o">=</span> <span class="n">string</span><span class="p">.</span><span class="n">ascii_lowercase</span>
        <span class="n">N</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="mi">9</span> <span class="o">+</span> <span class="mi">7</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">evil</span><span class="p">)</span>
      
        <span class="bp">self</span><span class="p">.</span><span class="n">con_numzero</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">con</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">CreateConnections</span><span class="p">(</span><span class="n">evil</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">alphabet</span><span class="p">))</span>
        <span class="n">res1</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">findLesserGood</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="s">"#"</span> <span class="o">+</span> <span class="n">s2</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">evil</span><span class="p">)</span>
        <span class="n">res2</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">findLesserGood</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="s">"#"</span> <span class="o">+</span> <span class="n">s1</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">evil</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">res1</span> <span class="o">-</span> <span class="n">res2</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">evil</span> <span class="ow">in</span> <span class="n">s1</span><span class="p">))</span> <span class="o">%</span> <span class="n">N</span>
</code></pre></div></div>
<h4 id="solution-2">Solution 2</h4>

<p>Here is much simpler solution with worse theoretical complexity but in fact it works quite fast. Let <code class="language-plaintext highlighter-rouge">comm(i, s)</code> be defined as the longest common suffix of <code class="language-plaintext highlighter-rouge">evil[:i] + s</code> which is equal to prefix of <code class="language-plaintext highlighter-rouge">evil</code>. Why we need it? Because we want to know what is the maximum number of symbols we already used from <code class="language-plaintext highlighter-rouge">evil</code>. 
Then we use function <code class="language-plaintext highlighter-rouge">dp(idx, pre, B1, B2)</code>, where <code class="language-plaintext highlighter-rouge">idx</code> is index we currently on, <code class="language-plaintext highlighter-rouge">pre</code> is how far we reached string <code class="language-plaintext highlighter-rouge">evil</code> and <code class="language-plaintext highlighter-rouge">B1</code> and <code class="language-plaintext highlighter-rouge">B2</code> are indicators of borders. Then:</p>

<ol>
  <li>If <code class="language-plaintext highlighter-rouge">pre == m</code>, it means, that we reached <code class="language-plaintext highlighter-rouge">evil</code>, so we not allowed to continue, return <code class="language-plaintext highlighter-rouge">0</code>.</li>
  <li>If <code class="language-plaintext highlighter-rouge">idx == n</code>, it means, that string is ended, we return <code class="language-plaintext highlighter-rouge">1</code>.</li>
  <li>Calculate <code class="language-plaintext highlighter-rouge">L</code> and <code class="language-plaintext highlighter-rouge">R</code>: range of symbols we can take.</li>
  <li>Finally, iterate over these symbols and run function recursively with new parameters.</li>
</ol>

<h4 id="complexity">Complexity:</h4>
<p>Time complexity of <code class="language-plaintext highlighter-rouge">comm</code> function part is $\mathcal{O}(k^3\cdot T)$, where $k$ is length of <code class="language-plaintext highlighter-rouge">evil</code> and $T$ is size of alphabet. Time complexity of <code class="language-plaintext highlighter-rouge">dp</code> is $\mathcal{O}(n\cdot k\cdot T)$, so final complexity is $\mathcal{O}(k^3\cdot T + n\cdot k\cdot T)$. Space complexity is $\mathcal{O}(k\cdot T + n\cdot k)$.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">findGoodStrings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">evil</span><span class="p">):</span>
        <span class="o">@</span><span class="n">lru_cache</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">comm</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>   <span class="c1">#given evil[:i] + s return common prefix 
</span>            <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">evil</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">s</span><span class="p">)[</span><span class="o">-</span><span class="n">j</span><span class="p">:]</span> <span class="o">==</span> <span class="n">evil</span><span class="p">[:</span><span class="n">j</span><span class="p">]:</span>
                    <span class="n">ans</span> <span class="o">=</span> <span class="n">j</span>
            <span class="k">return</span> <span class="n">ans</span>
        
        <span class="o">@</span><span class="n">lru_cache</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">dp</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">pre</span><span class="p">,</span> <span class="n">B1</span><span class="p">,</span> <span class="n">B2</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">pre</span> <span class="o">==</span> <span class="n">m</span><span class="p">:</span> <span class="k">return</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span> <span class="k">return</span> <span class="mi">1</span>
            
            <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">L</span> <span class="o">=</span> <span class="n">s2</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">if</span> <span class="n">B2</span> <span class="k">else</span> <span class="s">"z"</span>
            <span class="n">F</span> <span class="o">=</span> <span class="n">s1</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">if</span> <span class="n">B1</span> <span class="k">else</span> <span class="s">"a"</span>
            
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">alph</span><span class="p">[</span><span class="n">alph</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="n">F</span><span class="p">):</span><span class="n">alph</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="n">L</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">total</span> <span class="o">+=</span> <span class="n">dp</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">comm</span><span class="p">(</span><span class="n">pre</span><span class="p">,</span> <span class="n">c</span><span class="p">),</span> <span class="n">B1</span> <span class="ow">and</span> <span class="n">c</span> <span class="o">==</span> <span class="n">F</span><span class="p">,</span> <span class="n">B2</span> <span class="ow">and</span> <span class="n">c</span> <span class="o">==</span> <span class="n">L</span><span class="p">)</span>
                <span class="n">total</span> <span class="o">%=</span> <span class="n">N</span>
            
            <span class="k">return</span> <span class="n">total</span>
         
        <span class="n">m</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">alph</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">evil</span><span class="p">),</span> <span class="mi">10</span><span class="o">**</span><span class="mi">9</span> <span class="o">+</span> <span class="mi">7</span><span class="p">,</span> <span class="n">string</span><span class="p">.</span><span class="n">ascii_lowercase</span>
        <span class="k">return</span> <span class="n">dp</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">N</span>
</code></pre></div></div>

<p>If you like the solution, you can <strong>upvote</strong> it on leetcode discussion section:<a href="https://leetcode.com/problems/find-all-good-strings/discuss/655787/python-onk-kmp-with-dp-very-detailed-explanation"> <font color="blue">Problem 1397</font></a></p>

  </div><a class="u-url" href="/leetcode/1397.html" hidden></a>
</article>


      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
        <ul class="contact-list">
          <li class="p-name">Dmitry Babichev</li>
          <li><a class="u-email" href="mailto:dimitry008@gmail.com">dimitry008@gmail.com</a></li>
        </ul>
      </div>
      <div class="footer-col">
        <p>Here you can find solution to some algorithmic problems, at the moment it is mainly leetcode problems.
</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"></ul>
</div>

  </div>

</footer>
</body><script async src="https://www.googletagmanager.com/gtag/js?id=G-KR1GZKF62P"></script>
<script>
  window['ga-disable-G-KR1GZKF62P'] = window.doNotTrack === "1" || navigator.doNotTrack === "1" || navigator.doNotTrack === "yes" || navigator.msDoNotTrack === "1";
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-KR1GZKF62P');
</script>
</html>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    processEscapes: true
  }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>