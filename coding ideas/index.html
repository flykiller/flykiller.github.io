<!DOCTYPE html>
<html lang="en"><head>

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Patterns | Dmitry Babichev’s webpage</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Patterns" />
<meta name="author" content="Dmitry Babichev" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Here you can find solution to some algorithmic problems, at the moment it is mainly leetcode problems." />
<meta property="og:description" content="Here you can find solution to some algorithmic problems, at the moment it is mainly leetcode problems." />
<meta property="og:site_name" content="Dmitry Babichev’s webpage" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Patterns" />
<script type="application/ld+json">
{"url":"/coding%20ideas/","@type":"WebPage","headline":"Patterns","author":{"@type":"Person","name":"Dmitry Babichev"},"description":"Here you can find solution to some algorithmic problems, at the moment it is mainly leetcode problems.","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Dmitry Babichev's webpage" />
    






  
  
</head>

    
    <!-- for mathjax support -->
    
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Dmitry Babichev&#39;s webpage</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/leetcode%20problems/">Leetcode problems</a><a class="page-link" href="/coding%20ideas/">Patterns</a><a class="page-link" href="/coding%20ideas%202/">Patterns 2</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Patterns</h1>
  </header>

  <div class="post-content">
    <p>Here is a collection of different algorithms/ideas, which can be useful.</p>

<h4 id="tags">Tags</h4>
<p>Here is collection of different tags/ideas you should think of when you see new problem. Some of them will help to solve the problem, some of them like linked-list, just to make easier navigation among similar problems.</p>

<table class="tg">
<tbody>
  <tr>
    <th class="tg-0lax"> <a href="/tag/2d-array"> <font color="blue">2d-array</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/2sum"> <font color="blue">2sum</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/accumulate"> <font color="blue">accumulate</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/anagram"> <font color="blue">anagram</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/angle sweep"> <font color="blue">angle sweep</font> </a> </th>
  </tr>

  <tr>
    <th class="tg-0lax"> <a href="/tag/array"> <font color="blue">array</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/backtracking"> <font color="blue">backtracking</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/bfs"> <font color="blue">bfs</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/binary indexed tree"> <font color="blue">BIT(tree)</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/binary search"> <font color="blue">binary search</font> </a> </th>
  </tr>

  <tr>
    <th class="tg-0lax"> <a href="/tag/bit manipulation"> <font color="blue">bit manipulation</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/bit-dp"> <font color="blue">bit-dp</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/bst"> <font color="blue">bst</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/bucket sort"> <font color="blue">bucket sort</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/counter"> <font color="blue">counter</font> </a> </th>
  </tr>

  <tr>
    <th class="tg-0lax"> <a href="/tag/design"> <font color="blue">design</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/dfs"> <font color="blue">dfs</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/digit build"> <font color="blue">digit build</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/divide and conquer"> <font color="blue">divide &amp; conquer</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/dp"> <font color="blue">dp</font> </a> </th>
  </tr>

  <tr>
    <th class="tg-0lax"> <a href="/tag/dp-intervals"> <font color="blue">dp-intervals</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/game"> <font color="blue">game</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/generating functions"> <font color="blue">generating functions</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/geometry"> <font color="blue">geometry</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/graph"> <font color="blue">graph</font> </a> </th>
  </tr>

  <tr>
    <th class="tg-0lax"> <a href="/tag/graph algo"> <font color="blue">graph algo</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/greedy"> <font color="blue">greedy</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/groupby"> <font color="blue">groupby</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/hash table"> <font color="blue">hash table</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/heap"> <font color="blue">heap</font> </a> </th>
  </tr>

  <tr>
    <th class="tg-0lax"> <a href="/tag/inorder traversal"> <font color="blue">inorder traversal</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/interactive"> <font color="blue">interactive</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/intervals"> <font color="blue">intervals</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/kmp"> <font color="blue">kmp</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/line sweep"> <font color="blue">line sweep</font> </a> </th>
  </tr>

  <tr>
    <th class="tg-0lax"> <a href="/tag/linked list"> <font color="blue">linked list</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/math"> <font color="blue">math</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/matrix power"> <font color="blue">matrix power</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/meet in the middle"> <font color="blue">meet in the middle</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/merge sort"> <font color="blue">merge sort</font> </a> </th>
  </tr>

  <tr>
    <th class="tg-0lax"> <a href="/tag/monotonic deque"> <font color="blue">monotonic deque</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/morris traversal"> <font color="blue">morris traversal</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/palindrome"> <font color="blue">palindrome</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/parser"> <font color="blue">parser</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/permutation"> <font color="blue">permutation</font> </a> </th>
  </tr>

  <tr>
    <th class="tg-0lax"> <a href="/tag/queue"> <font color="blue">queue</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/quick select"> <font color="blue">quick select</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/random"> <font color="blue">random</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/recursion"> <font color="blue">recursion</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/rolling hash"> <font color="blue">rolling hash</font> </a> </th>
  </tr>

  <tr>
    <th class="tg-0lax"> <a href="/tag/segment tree"> <font color="blue">segment tree</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/simulation"> <font color="blue">simulation</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/sliding window"> <font color="blue">sliding window</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/sort"> <font color="blue">sort</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/stack"> <font color="blue">stack</font> </a> </th>
  </tr>

  <tr>
    <th class="tg-0lax"> <a href="/tag/string"> <font color="blue">string</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/suffix array"> <font color="blue">suffix array</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/three pointers"> <font color="blue">three pointers</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/topological sort"> <font color="blue">topological sort</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/tree"> <font color="blue">tree</font> </a> </th>
  </tr>

  <tr>
    <th class="tg-0lax"> <a href="/tag/trie"> <font color="blue">trie</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/two pointers"> <font color="blue">two pointers</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/union find"> <font color="blue">union find</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/voting"> <font color="blue">voting</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/sparse table"> <font color="blue">sparse table</font> </a> </th>
  </tr>

  <tr>
    <th class="tg-0lax"> <a href="/tag/binary lifting"> <font color="blue">binary lifting</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/connected components"> <font color="blue">connected components</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/LIS"> <font color="blue">LIS</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/sqrt decomposition"> <font color="blue">sqrt decomposition</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/spanning tree"> <font color="blue">spanning tree</font> </a> </th>
  </tr>

  <tr>
    <th class="tg-0lax"> <a href="/tag/knuth optimization"> <font color="blue">knuth optimization</font> </a> </th>
    <th class="tg-0lax"> <a href="/tag/interactive"> <font color="blue">interactive</font> </a> </th>
    <th class="tg-0lax">  </th>
    <th class="tg-0lax">  </th>
    <th class="tg-0lax">  </th>
  </tr>


</tbody>
</table>

<p><a href="/tag/2d-array"> <font color="blue"></font></a></p>

<h4 id="useful-tricks">Useful tricks:</h4>

<p>DP arrays</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">K</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span>
<span class="n">dp1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">M</span> 
<span class="n">dp2</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">M</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>    <span class="c1"># to create N x M array.
</span><span class="n">dp3</span> <span class="o">=</span> <span class="p">[[[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">M</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">K</span><span class="p">)]</span>   <span class="c1"># K x N x M  array
</span></code></pre></div></div>

<p>Flatten list of lists</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span>
<span class="n">equations</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]]</span>
<span class="nb">list</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">equations</span><span class="p">))</span>
</code></pre></div></div>

<p>Sort with lambda functions</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">result</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
<span class="n">result</span><span class="p">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">):</span> <span class="c1"># inplace
</span><span class="n">result</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="dijkstra-algorithm">Dijkstra Algorithm</h4>

<p>Let $n$ be number of nodes with numbers $0,1,\dots, n-1$ and <code class="language-plaintext highlighter-rouge">edges</code> be edges in form: <code class="language-plaintext highlighter-rouge">from, to, weight</code>. Let <code class="language-plaintext highlighter-rouge">start</code> and <code class="language-plaintext highlighter-rouge">end</code> be nodes between which we want to find minimal distance. Time complexity is $O((E+V)\log V)$, space complexity is $O(E+V)$.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">heapq</span> <span class="kn">import</span> <span class="n">heappop</span><span class="p">,</span> <span class="n">heappush</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">Dijkstra</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="s">'inf'</span><span class="p">)]</span> <span class="o">*</span> <span class="n">n</span>
        <span class="n">dist</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="n">G</span><span class="p">[</span><span class="n">a</span><span class="p">].</span><span class="n">append</span><span class="p">((</span><span class="n">b</span><span class="p">,</span> <span class="n">w</span><span class="p">))</span>
            <span class="n">G</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">append</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">w</span><span class="p">))</span>
        
        <span class="n">heap</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">start</span><span class="p">)]</span>

        <span class="k">while</span> <span class="n">heap</span><span class="p">:</span>
            <span class="p">(</span><span class="n">min_dist</span><span class="p">,</span> <span class="nb">id</span><span class="p">)</span> <span class="o">=</span> <span class="n">heappop</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">id</span> <span class="o">==</span> <span class="n">end</span><span class="p">:</span> <span class="k">return</span> <span class="n">min_dist</span>
            <span class="k">for</span> <span class="n">neibh</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="nb">id</span><span class="p">]:</span>
                <span class="n">cand</span> <span class="o">=</span> <span class="n">min_dist</span> <span class="o">+</span> <span class="n">weight</span>
                <span class="k">if</span> <span class="n">cand</span> <span class="o">&lt;</span> <span class="n">dist</span><span class="p">[</span><span class="n">neibh</span><span class="p">]:</span>
                    <span class="n">dist</span><span class="p">[</span><span class="n">neibh</span><span class="p">]</span> <span class="o">=</span> <span class="n">cand</span>
                    <span class="n">heappush</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="p">(</span><span class="n">cand</span><span class="p">,</span> <span class="n">neibh</span><span class="p">))</span>
                    
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</code></pre></div></div>

<h4 id="strongly-connected-components-tarjan">Strongly Connected Components, Tarjan</h4>

<p>Here is Tarjan algorithm to detect strongly connected components in directed graph. Time and space complexity is $O(E+V)$ (however with quite big constant, like 5-7). Input is directed unweighted graph and output will be list of length $n$, where for each node we have index of SCC.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span> 
   
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>       
    <span class="k">def</span> <span class="nf">SCCU_helper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span> 
        <span class="bp">self</span><span class="p">.</span><span class="n">disc</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">Time</span> 
        <span class="bp">self</span><span class="p">.</span><span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">Time</span> 
        <span class="bp">self</span><span class="p">.</span><span class="n">Time</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">stackMember</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">st</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> 
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span> 
            <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">disc</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="p">:</span> 
                <span class="bp">self</span><span class="p">.</span><span class="n">SCCU_helper</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> 
                <span class="bp">self</span><span class="p">.</span><span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="bp">self</span><span class="p">.</span><span class="n">low</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>       
            <span class="k">elif</span> <span class="bp">self</span><span class="p">.</span><span class="n">stackMember</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>  
                <span class="bp">self</span><span class="p">.</span><span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="bp">self</span><span class="p">.</span><span class="n">disc</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> 
  
        <span class="n">w</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">low</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="p">.</span><span class="n">disc</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span> 
            <span class="k">while</span> <span class="n">w</span> <span class="o">!=</span> <span class="n">u</span><span class="p">:</span> 
                <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">st</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span> 
                <span class="bp">self</span><span class="p">.</span><span class="n">comp</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">stackMember</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">SCC</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">connections</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">Time</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">disc</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>   <span class="c1">#discovery time
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">low</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>    <span class="c1">#low link
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">stackMember</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span> 
        <span class="bp">self</span><span class="p">.</span><span class="n">st</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">comp</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>     <span class="c1">#component number for each node
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">graph</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">connections</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span> 
            <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">disc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> 
                <span class="bp">self</span><span class="p">.</span><span class="n">SCCU_helper</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> 

        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">comp</span>
</code></pre></div></div>

<h4 id="strongly-connected-components-kosaraju">Strongly Connected Components, Kosaraju</h4>
<p>Here is Kosaraju algorithm to evaluate strongly connected components in graph, complexity is also $O(V + E)$.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def kosaraju(g, n):
    vis, l, comps = [False]*n, [0]*n, [0]*n
    global time
    time, transp = n, [[]] * n

    def visit(u):
        global time
        if vis[u]: return
        vis[u] = True
        for v in g[u]:
            visit(v)
            transp[v] = transp[v] + [u]
        time -= 1
        l[time] = u

    def assign(u, root):
        if not vis[u]: return
        vis[u] = False
        comps[u] = root
        for v in transp[u]:
            assign(v, root)

    for u in range(n): visit(u)
    for u in l: assign(u, u)
    return comps
</code></pre></div></div>

<h4 id="prefix-function-for-kmp">Prefix function for KMP</h4>

<p>Sometimes prefix function can be quite useful for some strings problems. The prefix function for this string is defined as an array $\pi$ of length $n$, where $\pi[i]$ is the length of the longest proper prefix of the substring <code class="language-plaintext highlighter-rouge">s[0...i]</code> which is also a suffix of this substring. A proper prefix of a string is a prefix that is not equal to the string itself. By definition, $\pi[0] = 0$.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">prefix</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">s</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">!=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>
    <span class="k">return</span> <span class="n">p</span>
</code></pre></div></div>

<h4 id="union-find-for-disjoint-sets">Union Find for disjoint sets</h4>

<p>Note, that <code class="language-plaintext highlighter-rouge">self.p</code> is <strong>not</strong> values of set for each node, but pointer to parent.</p>

<p>Without ranks implementation but with path compression. It has potentially $O(n)$ time complexity, but in practice, if data is not meant to broke it will work like $O(\log n)$ in average.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">DSU</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">p</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="n">xr</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">yr</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">p</span><span class="p">[</span><span class="n">xr</span><span class="p">]</span> <span class="o">=</span> <span class="n">yr</span>
</code></pre></div></div>

<p>If previous implementation is not enough, there is implementation with ranks and with path compressions, which will be $O(\mathcal{A}(n))$ complexity, where $\mathcal{A}(n)$ is inverse Ackermann funcion, which in fact grows so slow, that we can state that complexity is $O(1)$. Actually path compressions will make code just one line longer.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">DSU</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">par</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">rnk</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">N</span>

    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">par</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">par</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">par</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">par</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="n">xr</span><span class="p">,</span> <span class="n">yr</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="bp">self</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">xr</span> <span class="o">==</span> <span class="n">yr</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="p">.</span><span class="n">rnk</span><span class="p">[</span><span class="n">xr</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="p">.</span><span class="n">rnk</span><span class="p">[</span><span class="n">yr</span><span class="p">]:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">par</span><span class="p">[</span><span class="n">xr</span><span class="p">]</span> <span class="o">=</span> <span class="n">yr</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="p">.</span><span class="n">rnk</span><span class="p">[</span><span class="n">xr</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="p">.</span><span class="n">rnk</span><span class="p">[</span><span class="n">yr</span><span class="p">]:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">par</span><span class="p">[</span><span class="n">yr</span><span class="p">]</span> <span class="o">=</span> <span class="n">xr</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">par</span><span class="p">[</span><span class="n">yr</span><span class="p">]</span> <span class="o">=</span> <span class="n">xr</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">rnk</span><span class="p">[</span><span class="n">xr</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="bp">True</span>
</code></pre></div></div>

<h4 id="segment-tree-with-range-updates">Segment tree with range updates</h4>

<p>Here is universal Segment Tree with $O(\log n)$ complexities of each operation. What we need here is to be able to have the following data structure. Given numbers $x_1,\dots, x_n$, we want:</p>
<ol>
  <li>Find maximum (or another function <code class="language-plaintext highlighter-rouge">query_fn</code>, properties will be discussed later) on range <code class="language-plaintext highlighter-rouge">[l, r]</code>, this is query(self, v, tl, tr, l, r) and we want to do it in $O(\log n)$ complexity. We need to run it with arguments <code class="language-plaintext highlighter-rouge">(1, 0, n-1, l, r)</code> to get answer on range <code class="language-plaintext highlighter-rouge">[l, r]</code>. Here <code class="language-plaintext highlighter-rouge">v</code> is index of segment, <code class="language-plaintext highlighter-rouge">1</code> corresponds to range <code class="language-plaintext highlighter-rouge">[0, n-1]</code> and each segment have two children with indexes <code class="language-plaintext highlighter-rouge">2*v</code> and <code class="language-plaintext highlighter-rouge">2*v+1</code>, that is why we start indexing with <code class="language-plaintext highlighter-rouge">1</code>, not <code class="language-plaintext highlighter-rouge">0</code>.</li>
  <li>Update values for whole range <code class="language-plaintext highlighter-rouge">[l, r]</code>, using function <code class="language-plaintext highlighter-rouge">update_fn</code>. Note, that it is more difficult, that just to update one value, and we need to use so-called lazy updates. This is function <code class="language-plaintext highlighter-rouge">update(self, v, tl, tr, l, r, h)</code> We need to run it with arguments <code class="language-plaintext highlighter-rouge">(1, 0, n-1, l, r, h)</code>. Time complexity is also $O(\log n)$.</li>
</ol>

<p>Now, let us discuss possible choices of query and update functions. Denote <code class="language-plaintext highlighter-rouge">update_fn</code> by $\otimes$ and <code class="language-plaintext highlighter-rouge">query_fn</code> by $\oplus$, then they should have the following properties:</p>
<ol>
  <li>We have semigroup for binary operation $\oplus$: $(a\oplus b)\oplus c = a\oplus (b\oplus c); $</li>
  <li>We have monoid for binary operation $\otimes$:  $(a\otimes b)\otimes c = a\otimes (b\otimes c)$, $a\otimes e = e\otimes a = a$</li>
  <li>$\otimes$ is right-distributive over $\oplus$: $(a\otimes c)\oplus (b\otimes c) = (a\oplus b) \otimes c$</li>
</ol>

<p>Note also, that we can easily create so-called sparse segment tree: instead of list with zeroes, we can keep dictionary. Then space complexity for whole tree will be $O(k\log N)$ instead of $O(N)$, where $k$ is number of elements in tree.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">SegmentTree</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">update_fn</span><span class="p">,</span> <span class="n">query_fn</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">UF</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">QF</span> <span class="o">=</span> <span class="n">update_fn</span><span class="p">,</span> <span class="n">query_fn</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">T</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>   <span class="c1"># [0] * (4*N)
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">L</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>   <span class="c1"># [0] * (4*N)
</span>    
    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">v</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">T</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">UF</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">T</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="bp">self</span><span class="p">.</span><span class="n">L</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">L</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">UF</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">L</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="bp">self</span><span class="p">.</span><span class="n">L</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">L</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">tl</span><span class="p">,</span> <span class="n">tr</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="n">r</span><span class="p">:</span> <span class="k">return</span>
        <span class="k">if</span> <span class="n">l</span> <span class="o">==</span> <span class="n">tl</span> <span class="ow">and</span> <span class="n">r</span> <span class="o">==</span> <span class="n">tr</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">T</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">UF</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">T</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">h</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">L</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">UF</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">L</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">h</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="n">tm</span> <span class="o">=</span> <span class="p">(</span><span class="n">tl</span> <span class="o">+</span> <span class="n">tr</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">tl</span><span class="p">,</span> <span class="n">tm</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">tm</span><span class="p">),</span> <span class="n">h</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">tr</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">r</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">T</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">QF</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">T</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">],</span> <span class="bp">self</span><span class="p">.</span><span class="n">T</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">tl</span><span class="p">,</span> <span class="n">tr</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="n">r</span><span class="p">:</span> <span class="k">return</span> <span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="s">"inf"</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">l</span> <span class="o">&lt;=</span> <span class="n">tl</span> <span class="ow">and</span> <span class="n">tr</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">T</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="n">tm</span> <span class="o">=</span> <span class="p">(</span><span class="n">tl</span> <span class="o">+</span> <span class="n">tr</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">QF</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">query</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">tl</span><span class="p">,</span> <span class="n">tm</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">tm</span><span class="p">)),</span> <span class="bp">self</span><span class="p">.</span><span class="n">query</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">tr</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">r</span><span class="p">))</span>
</code></pre></div></div>

<h4 id="segment-trees-without-range-updates">Segment Trees without range updates</h4>
<p>Here is lighter version, which works faster.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">SegmentTree</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">update_fn</span><span class="p">,</span> <span class="n">query_fn</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">UF</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">QF</span> <span class="o">=</span> <span class="n">update_fn</span><span class="p">,</span> <span class="n">query_fn</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">T</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>  

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">tl</span><span class="p">,</span> <span class="n">tr</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">tl</span> <span class="o">==</span> <span class="n">tr</span><span class="p">:</span> 
            <span class="bp">self</span><span class="p">.</span><span class="n">T</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">UF</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">T</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">h</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tm</span> <span class="o">=</span> <span class="p">(</span><span class="n">tl</span> <span class="o">+</span> <span class="n">tr</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
            <span class="k">if</span> <span class="n">pos</span> <span class="o">&lt;=</span> <span class="n">tm</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">tl</span><span class="p">,</span> <span class="n">tm</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">tr</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">T</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">QF</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">T</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">],</span> <span class="bp">self</span><span class="p">.</span><span class="n">T</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">tl</span><span class="p">,</span> <span class="n">tr</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="n">r</span><span class="p">:</span> <span class="k">return</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">l</span> <span class="o">==</span> <span class="n">tl</span> <span class="ow">and</span> <span class="n">r</span> <span class="o">==</span> <span class="n">tr</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">T</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
        <span class="n">tm</span> <span class="o">=</span> <span class="p">(</span><span class="n">tl</span> <span class="o">+</span> <span class="n">tr</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">QF</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">query</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">tl</span><span class="p">,</span> <span class="n">tm</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">tm</span><span class="p">)),</span> <span class="bp">self</span><span class="p">.</span><span class="n">query</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">tr</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">r</span><span class="p">))</span>
</code></pre></div></div>

<h4 id="binary-indexed-trees-">Binary Indexed Trees (`)</h4>
<p>This data structure is less flexible than segment trees, but much more easier to code. Here is implemenation to have queries of sums of numbers in the form <code class="language-plaintext highlighter-rouge">[0, i]</code>, also it is easy to do ranges <code class="language-plaintext highlighter-rouge">[i, j]</code>. We can choose another function (which what properties?), such that we only can answer <code class="language-plaintext highlighter-rouge">[0, i]</code> queries, for example to evaluate <code class="language-plaintext highlighter-rouge">max</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">BIT</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">sums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">delta</span><span class="p">):</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">sums</span><span class="p">):</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">sums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">delta</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">-</span><span class="n">i</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="bp">self</span><span class="p">.</span><span class="n">sums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">i</span> <span class="o">-=</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">-</span><span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">query</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="p">.</span><span class="n">query</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<h5 id="advanced-version">advanced version.</h5>
<ol>
  <li><code class="language-plaintext highlighter-rouge">__init__(self, x)</code> will transform list <code class="language-plaintext highlighter-rouge">x</code> to BIT in <code class="language-plaintext highlighter-rouge">O(n)</code> time.</li>
  <li><code class="language-plaintext highlighter-rouge">update(self, idx, x)</code> will update <code class="language-plaintext highlighter-rouge">bit[idx] += x</code> in <code class="language-plaintext highlighter-rouge">O(log n)</code> time.</li>
  <li><code class="language-plaintext highlighter-rouge">query(self, i)</code> will calculate <code class="language-plaintext highlighter-rouge">sum(bit[:i])</code>, be careful here, <code class="language-plaintext highlighter-rouge">i</code> is not included in <code class="language-plaintext highlighter-rouge">O(log n)</code> time</li>
  <li><code class="language-plaintext highlighter-rouge">findkth(self, k)</code> find largest <code class="language-plaintext highlighter-rouge">idx</code> such that <code class="language-plaintext highlighter-rouge">sum(bit[:idx]) &lt;= k</code> in `O(log^2 n) time).</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">BIT</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">bit</span> <span class="o">=</span> <span class="n">x</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">|</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">while</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">bit</span><span class="p">):</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">bit</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">x</span>
            <span class="n">idx</span> <span class="o">|=</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">i</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">+=</span> <span class="bp">self</span><span class="p">.</span><span class="n">bit</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">i</span> <span class="o">&amp;=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">x</span>

    <span class="k">def</span> <span class="nf">findkth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">bit</span><span class="p">).</span><span class="n">bit_length</span><span class="p">())):</span>
            <span class="n">right_idx</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">d</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">right_idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">bit</span><span class="p">)</span> <span class="ow">and</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="p">.</span><span class="n">bit</span><span class="p">[</span><span class="n">right_idx</span><span class="p">]:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">right_idx</span>
                <span class="n">k</span> <span class="o">-=</span> <span class="bp">self</span><span class="p">.</span><span class="n">bit</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span>
</code></pre></div></div>

<h4 id="manacher-algorighm-for-palindromes">Manacher algorighm for palindromes</h4>
<p>Not very frequent algorithm, but quite elegant.
It will return lengths of longest palindromes for all $2n-1$ places (there are odd and even places). Time and space complexity is $O(n)$. In my opinion it is quite similar to KMP algorithm.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">manachers</span><span class="p">(</span><span class="n">S</span><span class="p">):</span>
    <span class="n">A</span> <span class="o">=</span> <span class="s">'@#'</span> <span class="o">+</span> <span class="s">'#'</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">S</span><span class="p">)</span> <span class="o">+</span> <span class="s">'#$'</span>
    <span class="n">Z</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">center</span> <span class="o">=</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">:</span>
            <span class="n">Z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">i</span><span class="p">,</span> <span class="n">Z</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">center</span> <span class="o">-</span> <span class="n">i</span><span class="p">])</span>
        <span class="k">while</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">Z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">Z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="n">Z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="n">Z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">right</span><span class="p">:</span>
            <span class="n">center</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">Z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">Z</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
</code></pre></div></div>

<h4 id="trie-data-structure">Trie data structure</h4>

<p>Here is implementation of trie, it is not the shortest one, but in this way you can modify it easily if needed. Here function <code class="language-plaintext highlighter-rouge">search(word)</code> will check if we have given <code class="language-plaintext highlighter-rouge">word</code> in our trie and <code class="language-plaintext highlighter-rouge">startsWith(prefix)</code> will check if we have words starting with prefix.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TrieNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">end_node</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">class</span> <span class="nc">Trie</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">TrieNode</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">):</span> <span class="c1">#None
</span>        <span class="n">root</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">root</span>
        <span class="k">for</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="n">word</span><span class="p">:</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="p">.</span><span class="n">children</span><span class="p">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">TrieNode</span><span class="p">())</span>
        <span class="n">root</span><span class="p">.</span><span class="n">end_node</span> <span class="o">=</span> <span class="mi">1</span>
        
    <span class="k">def</span> <span class="nf">searchHelper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">):</span>
        <span class="n">root</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">root</span>
        <span class="k">for</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="n">word</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="n">root</span><span class="p">.</span><span class="n">children</span><span class="p">:</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="p">.</span><span class="n">children</span><span class="p">[</span><span class="n">symbol</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">return</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">root</span><span class="p">.</span><span class="n">end_node</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span>  


    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">):</span> <span class="c1">#bool:
</span>        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">searchHelper</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">startsWith</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix</span><span class="p">):</span> <span class="c1">#bool:
</span>        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">searchHelper</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span>  
</code></pre></div></div>

<h4 id="floyd-warshall-algorithm">Floyd-Warshall algorithm</h4>
<p>It will find the shortest paths between all pairs of nodes in $O(n^3)$ time, where $n$ is number of nodes.</p>

<h4 id="bellman-ford-algorithm">Bellman-Ford algorithm</h4>
<p>It will find shortest paths from given node to all others, if we can have negative weights, but not negative cycles. Time complexity is $O(mn)$, where $m$ is number of edges and $n$ is number of nodes.</p>

<h4 id="topological-sort">Topological sort</h4>
<p>Given graph, check if it is DAG, and if it is, give the correct order of nodes, if not, return $[]$. Here is code which use BFS, time and space complexity is $O(V + E)$. <code class="language-plaintext highlighter-rouge">verts</code> is list of vertices and <code class="language-plaintext highlighter-rouge">E</code> is list of edges.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">Topological</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="n">edges</span><span class="p">):</span>
    <span class="n">pre</span><span class="p">,</span> <span class="n">suc</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
        <span class="n">pre</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">suc</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="n">free</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">verts</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">pre</span><span class="p">),</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">free</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">free</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">out</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">suc</span><span class="p">[</span><span class="n">a</span><span class="p">]:</span>
            <span class="n">pre</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">pre</span><span class="p">[</span><span class="n">b</span><span class="p">]:</span> <span class="n">free</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">verts</span><span class="p">))</span>
</code></pre></div></div>

<h4 id="convex-hull-jarvis-algorithm-and-graham-scan">Convex Hull: Jarvis algorithm and Graham Scan</h4>
<p>This algorithm will give us the convex hull of given set of points on the plane.</p>

<h4 id="sprague-grundy-theorem">Sprague-Grundy theorem</h4>
<p>Useful if we have game problem which is sum of games. (add example?)</p>

<h4 id="modular-arithmetics-and-number-theory-from-e-maxx">Modular arithmetics and number theory (from e-maxx)</h4>
<p>Euler theorem: $a^{\phi(m)} \equiv 1 (m)$, where $(a, m) = 1$, where $\phi(m)$ is Euler function, can be used to find inverse element in $O(\log m)$ time complexity: $a^{-1} = a^{\phi(m)-1} $ However in python 3.8 inverse element is implemented already.</p>

<p>To evaluate $a^n\pmod m$ we can use binary expontiation with $O(\log n)$ complexity.</p>

<p>To evaluate $gcd(a, b)$ we can use Euclid algorithm with complexity $O(\log(a+b))$, then we can find lcm.</p>

<p>To find all prime numbers in $[1, n]$ we can use Sieve of Eratosthenes with complexity $O(n\log\log n)$. There is also algorithm with $O(n)$ complexity but in practice it is not worth it, difference is very small.</p>

<p>To solve equation $ax + by = c$ in whole numbers, we can use Euclid algorithm: first find one solution and then we can parametrize all solutions. If we need some restricted solutions, we just write down conditions for parameter.</p>

<p>To solve recurrent equations, like fibonacci, we can use fast matrix expontiation with complexity $O(m^3\cdot \log n)$, where $m$ is order of recurrence (2 for fibonacci) and $n$ is term we want to get.</p>

<p>Given module $m$ we can find $1^{-1}, 2^{-1}, \dots, n^{-1}$ for any $n$ in just $O(n)$ time.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">m</span><span class="o">//</span><span class="n">i</span><span class="o">*</span><span class="n">r</span><span class="p">[</span><span class="n">m</span><span class="o">%</span><span class="n">i</span><span class="p">]</span><span class="o">%</span><span class="n">m</span><span class="p">)</span><span class="o">%</span><span class="n">m</span>
</code></pre></div></div>

<p>To solve equation (discrete logarithm) $a^x \equiv b (m)$ if $(a, m) = 1$ we can use idea of meet-in-the-middle with complexity $O(\sqrt{m})$, this is called Shanks theorem.</p>

<p>To solve chiniese reminder theorem we can use Garner algorithm.</p>

<p>For checking all submasks of given masks in $O(3^n)$, check Leetcode problem 1655.</p>

<p>To solve $x^k \equiv a(n)$ (discrete root) we need to find primitive root first and then reduce problem to discrete logarithm problem.</p>

<p>For fast multiplication of two polynomials we can use Fast Fourier Transform (FFT), which is actually implemented in python, in convolution 1d function.</p>

<p>There are different ways to check if number if prime and do factorization of big numbers, but it is out of scope here.</p>

<h4 id="graphs-from-e-maxx">Graphs (from e-maxx)</h4>

<p>dfs, bfs, topological sort, connected components</p>

<p>Strongly connected components, <strong>SCC</strong> (Kosaraju’s algorithm) will find them in $O(V+E)$ time.</p>

<p><strong>Bridges</strong> in graph, Tarjan algorithm, leetcode 1192. Bridges partition graph into biconnected edge components, goal is to find all bridges in graph in $O(V + E)$ time.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">criticalConnections</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">connections</span><span class="p">):</span>
        <span class="n">used</span><span class="p">,</span> <span class="n">tin</span><span class="p">,</span> <span class="n">fup</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">timer</span><span class="p">,</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[]</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">par</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">used</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">tin</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">fup</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">timer</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">timer</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">par</span><span class="p">:</span> <span class="k">continue</span>
                <span class="k">if</span> <span class="n">used</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">fup</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">fup</span><span class="p">[</span><span class="n">node</span><span class="p">],</span> <span class="n">tin</span><span class="p">[</span><span class="n">child</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dfs</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
                    <span class="n">fup</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">fup</span><span class="p">[</span><span class="n">node</span><span class="p">],</span> <span class="n">fup</span><span class="p">[</span><span class="n">child</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">fup</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">tin</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span> <span class="n">ans</span><span class="p">.</span><span class="n">append</span><span class="p">([</span><span class="n">node</span><span class="p">,</span> <span class="n">child</span><span class="p">])</span>
        
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">connections</span><span class="p">:</span>
            <span class="n">graph</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
            <span class="n">graph</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">used</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                
        <span class="k">return</span> <span class="n">ans</span>
</code></pre></div></div>

<p><strong>Articulation points</strong> in graphs: such points which being removed break graph into parts. Articulation points partition graph into biconnected vertex components. Here is implementation of classical algorithm. Note that it is very similar to bridges with small differences:</p>

<ol>
  <li>It is <code class="language-plaintext highlighter-rouge">fup[child] &gt;= tin[node]</code> instead of <code class="language-plaintext highlighter-rouge">fup[child] &gt; fup[node]</code>.</li>
  <li>We also keep <code class="language-plaintext highlighter-rouge">children</code>: number of connections and make one more check if <code class="language-plaintext highlighter-rouge">par = -1</code> and number of children more than one (it means, they can not have common descendents), then this is also articulation point.</li>
  <li>Finally, we keep set of articulation points, not list, because one node can be visited several times during traversal.</li>
</ol>

<p>See also problem <strong>0928</strong>, where one of the solutions can use this idea.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">ArticulationPoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">connections</span><span class="p">):</span>
        <span class="n">used</span><span class="p">,</span> <span class="n">tin</span><span class="p">,</span> <span class="n">fup</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">timer</span><span class="p">,</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">par</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">used</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">tin</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">fup</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">timer</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">timer</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">children</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">par</span><span class="p">:</span> <span class="k">continue</span>
                <span class="k">if</span> <span class="n">used</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">fup</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">fup</span><span class="p">[</span><span class="n">node</span><span class="p">],</span> <span class="n">tin</span><span class="p">[</span><span class="n">child</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dfs</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
                    <span class="n">fup</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">fup</span><span class="p">[</span><span class="n">node</span><span class="p">],</span> <span class="n">fup</span><span class="p">[</span><span class="n">child</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">fup</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">tin</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="ow">and</span> <span class="n">par</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="n">ans</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                    <span class="n">children</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">par</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">children</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span> <span class="n">ans</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">connections</span><span class="p">:</span>
            <span class="n">graph</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
            <span class="n">graph</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">used</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                
        <span class="k">return</span> <span class="n">ans</span>
</code></pre></div></div>

<p><strong>Bridges</strong> online. If we want to find the number of brides when we change our graph: add edge by edge. There is $O(n\log n + m)$ time complexity algorithm, where $m$ is number of edges (queries) and $n$ is number of nodes. The idea is to use two DSU structures: one for connected components and another for biconnected components.</p>

<p>To find <strong>spanning tree</strong> of graph we can use Prim’s algorithm or Kruskal’s algorithm (with dsu) with $O(m\log n)$ time complexity. There is also a way to find number of spanning trees with $O(n^3)$ complexity, using Kirchhoff’s theorem.</p>

<p>Prufer sequence and Cayley’s formula helps to enumerate all spanning trees of full graph as well as number of ways to make graph full, adding minumal number of nodes.</p>

<p><strong>Euler</strong> path in graph can be found in $O(E)$ time complexity, see Leetcode 0332.</p>

<p>Least common ancestor <strong>LCA</strong> and range minimum query <strong>RMQ</strong>: there are a lot of different ways to solve these problems, with $O(n)$ preprocessing and $O(1)$ time being the best solution.</p>

<p>Maximum flow/Minimum cut algorithms: Edmonds-Karp with $O(VE^2)$ time complexity, Ford-Fulkerson with $O(Ef)$, where $f$ is maximal flow, but it can have infinite loop if weights are not integer. Push-relabel maximum flow with $O(V^2\sqrt{E})$ complexity.</p>

<p>Hungarian algorithm: given matrix of size $n\times n$, we need to put $n$ rooks, which don’t beat each other such that sum of all cells they occupy is minumal. There is $O(n^3)$ algorithm.</p>

<p>Kuhn’ Algorithm — Maximum Bipartite Matching, complexity is $O(mn)$.</p>

<h4 id="suffix-array">Suffix array</h4>
<p>Let us consider for simplicity example <code class="language-plaintext highlighter-rouge">banana</code>. Then what we want to construct is list of all suffixes: <code class="language-plaintext highlighter-rouge">banana, anana, nana, ana, na, a</code> and then sort them in increasing order: we have <code class="language-plaintext highlighter-rouge">a, ana, anana, banana, na, nana</code>. Actually what we keep is order if indexes: <code class="language-plaintext highlighter-rouge">(5, 3, 1, 0, 4, 2)</code>, this is called suffix array.</p>

<p>function <code class="language-plaintext highlighter-rouge">suffixArray</code> given list s returns two pieces of information: <code class="language-plaintext highlighter-rouge">sa</code> is suffix array itself and <code class="language-plaintext highlighter-rouge">ans</code> is list of ranks for substrings of lengths `1, 2, 4, … We can need it for example to compare substrings in O(1) later.</p>

<p>Complexity of construction is $O(n\log^2n)$, but in practice it works quite fast in python, due to built-in sort function. One small optimization is to change break condition <code class="language-plaintext highlighter-rouge">while k &lt; n - 1</code> to <code class="language-plaintext highlighter-rouge">while max(line) &lt; n - 1</code> which will break earlier if all ranks are different already.</p>

<p>There is similar way we can do it in $O(n \log n)$ complexity, but in practice it works even slower, because we need to perform bucket sort by hands which will be slow because we need to work with indexes a lot. There is in fact $O(n)$ algorithm constructing suffix trees first, but it is quite painful.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">ranks</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
    <span class="n">index</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">l</span><span class="p">)))}</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">l</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">suffixArray</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">ranks</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">ans</span><span class="p">,</span> <span class="n">sa</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="n">line</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="k">while</span> <span class="nb">max</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1">#k &lt; n - 1 without optimization
</span>        <span class="n">line</span> <span class="o">=</span> <span class="n">ranks</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">zip_longest</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">islice</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span> <span class="n">fillvalue</span><span class="o">=-</span><span class="mi">1</span><span class="p">)))</span>
        <span class="n">ans</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">ans</span> <span class="o">+</span> <span class="p">[</span><span class="n">line</span><span class="p">],</span> <span class="n">k</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ans</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span> <span class="n">sa</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
    <span class="k">return</span> <span class="n">ans</span><span class="p">,</span> <span class="n">sa</span>
</code></pre></div></div>

<p>After we constructed suffixArray, we can construct LCP array in $O(n)$ time: this array will consist of biggest common prefixes lengths between pair of adjacent suffixes in suffix array, for our <code class="language-plaintext highlighter-rouge">banana</code> example we have <code class="language-plaintext highlighter-rouge">a, ana, anana, banana, na, nana</code>, so answer is <code class="language-plaintext highlighter-rouge">1, 3, 0, 0, 2</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">lcp</span><span class="p">(</span><span class="n">Arr</span><span class="p">,</span> <span class="n">suffixArr</span><span class="p">,</span> <span class="n">inv_suff</span><span class="p">):</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">ans</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">),</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">),</span> <span class="mi">0</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">inv_suff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">continue</span>

        <span class="n">j</span> <span class="o">=</span> <span class="n">suffixArr</span><span class="p">[</span><span class="n">inv_suff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">+</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">+</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="n">k</span><span class="p">]:</span>
            <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">ans</span><span class="p">[</span><span class="n">inv_suff</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">k</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">k</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">ans</span>
</code></pre></div></div>

<h4 id="fast-matrix-moduly-expontiation">Fast matrix moduly expontiation</h4>
<p>Given $A$ $T\times T$ size square matrix, we need to evaluate $A^n$ modulo <code class="language-plaintext highlighter-rouge">MOD</code>. It can be done in $O(T^3\log n)$ time, using doubling trick. It is useful for some types of dynamic programming problems. If we use classical <code class="language-plaintext highlighter-rouge">MOD = 10^9 + 7</code>, then to avoid overflow we can use this only in case when $T\leqslant 8$. Depending on problem specific it can work for $T &gt; 8$, but we can not be sure.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">power</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">MOD</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">eye</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">M</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n</span><span class="o">%</span><span class="mi">2</span><span class="p">:</span> <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span> <span class="o">%</span> <span class="n">MOD</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span> <span class="o">%</span> <span class="n">MOD</span>
        <span class="n">n</span> <span class="o">//=</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div>

<p>If we want to make it work for $T &gt; 8$ we have to used slower version with multiplication by hands:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">mult</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">MOD</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[[</span><span class="nb">sum</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">b</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span><span class="o">%</span><span class="n">MOD</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">Y</span><span class="p">)]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">X</span><span class="p">]</span>
        
<span class="k">def</span> <span class="nf">power</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">MOD</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">M</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">M</span><span class="p">))]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">M</span><span class="p">)):</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n</span><span class="o">%</span><span class="mi">2</span><span class="p">:</span> <span class="n">result</span> <span class="o">=</span> <span class="n">mult</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">MOD</span><span class="p">)</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">mult</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">MOD</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">//=</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div>

<h4 id="factorials">Factorials</h4>
<p>Sometimes it is useful to precalculate all factorials and inverse factorials given prime modulo: then we can evaluate numbers of combinations in <code class="language-plaintext highlighter-rouge">O(1)</code>. Time to precalculate is <code class="language-plaintext highlighter-rouge">O(M)</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">MOD</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="mi">9</span> <span class="o">+</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">10</span><span class="o">**</span><span class="mi">5</span>
<span class="n">F</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">M</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">M</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="n">MOD</span>

<span class="n">I</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">M</span> <span class="o">+</span> <span class="p">[</span><span class="nb">pow</span><span class="p">(</span><span class="n">F</span><span class="p">[</span><span class="n">M</span><span class="p">],</span> <span class="n">MOD</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">MOD</span><span class="p">)]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">MOD</span>
</code></pre></div></div>

<h4 id="prime-factorization">Prime factorization</h4>
<p>If we want to have fast factorization of small numbers, we can precalculate all smallest prime factors. Time to precalculate is <code class="language-plaintext highlighter-rouge">O(M log M)</code> and then time to factorize is <code class="language-plaintext highlighter-rouge">O(log M)</code>.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">M</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">M</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">M</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>

<span class="k">def</span> <span class="nf">factorize</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
    <span class="n">primes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">arr</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">primes</span> <span class="o">+=</span> <span class="p">[</span><span class="n">arr</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span>
        <span class="n">k</span> <span class="o">//=</span> <span class="n">arr</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">primes</span>
</code></pre></div></div>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
        <ul class="contact-list">
          <li class="p-name">Dmitry Babichev</li>
          <li><a class="u-email" href="mailto:dimitry008@gmail.com">dimitry008@gmail.com</a></li>
        </ul>
      </div>
      <div class="footer-col">
        <p>Here you can find solution to some algorithmic problems, at the moment it is mainly leetcode problems.
</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"></ul>
</div>

  </div>

</footer>
</body>

</html>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    processEscapes: true
  }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>